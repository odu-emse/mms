<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>mms.utils.seed API documentation</title>
<meta name="description" content="" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>mms.utils.seed</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">from enum import Enum
import os
from typing import Union

from essential_generators import DocumentGenerator
from numpy import random
from prisma import Prisma
import logging
from requests import post
from utils.sdl import createMutationString, createModuleMutationString


async def seedUserDB():
    print(&#39;Seeding user model...&#39;)
    prisma = Prisma()
    await prisma.connect()
    gen = DocumentGenerator()
    iterations = 25
    accounts = []

    for i in range(iterations):
        accounts.append({
            &#39;firstName&#39;: gen.name(),
            &#39;lastName&#39;: gen.name(),
            &#39;email&#39;: gen.email(),
            &#39;openID&#39;: str(gen.integer()),
        })

    users = await prisma.user.create_many(data=accounts)

    print(&#39;User model seeded successfully with %d documents!&#39; % users)
    await prisma.disconnect()


async def seedPlanOfStudyDB():
    print(&#39;Seeding plan of study model...&#39;)
    gen = DocumentGenerator()
    prisma = Prisma()
    await prisma.connect()

    modules = await prisma.module.find_many()
    accounts = await prisma.user.find_many()

    for account in accounts:
        for module in modules:
            # create plan of study for each module 25 times
            await prisma.planofstudy.create(
                data={
                    &#34;modules&#34;: {
                        &#34;connect&#34;: {
                            &#34;id&#34;: module.get(&#39;id&#39;)
                        }
                    },
                    &#34;student&#34;: {
                        &#34;connect&#34;: {
                            &#34;id&#34;: account[&#39;id&#39;]
                        }
                    }
                }
            )

    print(&#39;Plan of study model seeded successfully!&#39;)


def seedDbFeedback():
    print(&#39;Seeding feedback model...&#39;)
    gen = DocumentGenerator()
    iterations = 25
    modules = getModules()[&#39;module&#39;]
    for module in modules:
        # create feedback for each module 25 times
        for i in range(iterations):
            res = post(&#39;http://%s/graphql&#39; % os.environ.get(&#34;API_URL&#34;, &#34;localhost:4000&#34;),
                       {},
                       {&#39;query&#39;: createMutationString(
                           comment=gen.sentence(),
                           rating=random.randint(1, 6),
                           moduleID=module[&#39;id&#39;],
                       )
                       })
            print(res.json())

    print(&#39;Feedback model seeded successfully!&#39;)


def seedModuleModel():
    print(&#39;Seeding module model...&#39;)
    gen = DocumentGenerator()
    iterations = 25
    for i in range(iterations):
        key_length = random.randint(1, 11)
        res = post(&#39;http://%s/graphql&#39; % os.environ.get(&#34;API_URL&#34;, &#34;localhost:4000&#34;),
                   {},
                   {&#39;query&#39;: createModuleMutationString(
                       moduleName=gen.word(),
                       moduleNumber=random.randint(1, 1000),
                       description=gen.sentence(),
                       duration=random.randint(1, 100),
                       intro=gen.sentence(),
                       numSlides=random.randint(1, 100),
                       keywords=[gen.word() for i in range(key_length)]
                   )
                   })
        print(res.json())

    print(&#39;Module model seeded successfully!&#39;)


def getModules():
    mods = post(&#39;http://%s/graphql&#39; % os.environ.get(&#34;API_URL&#34;, &#34;localhost:4000&#34;), {}, {
        &#39;query&#39;: &#34;&#34;&#34;query{
          module(input:{}){
            id
            moduleName
            moduleNumber
          }
        }&#34;&#34;&#34;
    })
    return mods.json()[&#39;data&#39;]


def getModuleFeedback():
    mods = post(&#39;http://%s/graphql&#39; % os.environ.get(&#34;API_URL&#34;, &#34;localhost:4000&#34;), {}, {
        &#39;query&#39;: &#34;&#34;&#34;query{
          module(input:{}){
            id
            moduleName
            moduleNumber
            feedback{
              rating
              feedback
            }
            members{
              id
            }
          }
        }&#34;&#34;&#34;
    })
    return mods.json()[&#39;data&#39;]


class Skipper(Enum):
    user = 1
    module = 2
    feedback = 3
    plan = 4
    enrollment = 5
    all = 6


class Seeder:
    &#34;&#34;&#34;
    Seeder class for seeding the database with dummy data. Makes use of the prisma python client to connection to the
    database and the essential_generators library to create document templates.
    &#34;&#34;&#34;

    def __init__(self, skip: [Skipper] = None, cleanup: [Skipper] = None, iterations: int = 25):
        self.gen = DocumentGenerator()
        self.gen.init_word_cache(5000)
        self.gen.init_sentence_cache(5000)
        self.prisma = Prisma()
        self.iterations = iterations
        self.accounts = []
        self.modules = []
        self.enrollments = []
        self.feedbacks = []
        self.plans = []
        self.skip = skip
        self.cleanup = cleanup
        self.logger = logging.getLogger(&#39;__seed__&#39;)
        logging.basicConfig(format=&#39;%(levelname)s:%(message)s&#39;, level=logging.INFO)

    async def connect(self):
        &#34;&#34;&#34;
        Connects to the database using prisma client.
        &#34;&#34;&#34;
        await self.prisma.connect()

    async def disconnect(self):
        &#34;&#34;&#34;
        Disconnects from the database using prisma client.
        &#34;&#34;&#34;
        await self.prisma.disconnect()

    async def _getUserAccounts(self):
        &#34;&#34;&#34;
        Gets all user accounts from the database and returns them as a list of dictionaries.
        :return: class&lt;list&gt; of class&lt;dict&gt; of type&lt;User&gt;
        &#34;&#34;&#34;
        accounts = await self.prisma.user.find_many()

        acc = []

        for i in range(len(accounts)):
            acc.append(accounts[i].dict())

        return acc

    async def _getModules(self):
        &#34;&#34;&#34;
        Gets all modules from the database and returns them as a list of dictionaries.
        :return: class&lt;list&gt; of class&lt;dict&gt; of type&lt;Module&gt;
        &#34;&#34;&#34;
        self.modules = await self.prisma.module.find_many()

        mods = []

        for i in range(len(self.modules)):
            mods.append(self.modules[i].dict())

        return mods

    async def _getEnrollments(self):
        &#34;&#34;&#34;
        Gets all enrollments from the database and returns them as a list of dictionaries.
        :return: class&lt;list&gt; of class&lt;dict&gt; of type&lt;ModuleEnrollment&gt;
        &#34;&#34;&#34;
        self.enrollments = await self.prisma.moduleenrollment.find_many()

        enrollments = []

        for i in range(len(self.enrollments)):
            enrollments.append(self.enrollments[i].dict())

        return enrollments

    async def _getFeedbacks(self):
        &#34;&#34;&#34;
        Gets all feedbacks from the database and returns them as a list of dictionaries.
        :return: class&lt;list&gt; of class&lt;dict&gt; of type&lt;ModuleFeedback&gt;
        &#34;&#34;&#34;
        self.feedbacks = await self.prisma.modulefeedback.find_many()

        feedbacks = []

        for i in range(len(self.feedbacks)):
            feedbacks.append(self.feedbacks[i].dict())

        return feedbacks

    async def _getPlans(self) -&gt; list[dict]:
        self.plans = await self.prisma.planofstudy.find_many()

        plans = []

        for i in range(len(self.plans)):
            plans.append(self.plans[i].dict())

        return plans

    async def _seedUserDB(self):
        &#34;&#34;&#34;
        Seeds the user model with dummy data as many times as described by the iterations&#39; member.
        :return: None
        &#34;&#34;&#34;
        self.logger.info(&#39;Seeding user model...&#39;)
        accounts = []

        for i in range(self.iterations):
            accounts.append({
                &#39;firstName&#39;: self.gen.name(),
                &#39;lastName&#39;: self.gen.name(),
                &#39;email&#39;: self.gen.email(),
                &#39;openID&#39;: str(self.gen.integer()),
            })

        users = await self.prisma.user.create_many(data=accounts)

        self.accounts = accounts
        self.logger.info(&#39;User model seeded successfully with %d documents!&#39; % users)

    async def _seedModuleDB(self):
        &#34;&#34;&#34;
        Seeds the module model with dummy data as many times as described by the iterations&#39; member.
        :return: None
        &#34;&#34;&#34;
        self.logger.info(&#39;Seeding module model...&#39;)
        modules = []

        template = {
            &#39;moduleName&#39;: {
                &#39;typemap&#39;: &#39;sentence&#39;,
                &#39;unique&#39;: True,
                &#39;tries&#39;: 100
            },
            &#39;moduleNumber&#39;: {
                &#39;typemap&#39;: &#39;integer&#39;,
                &#39;unique&#39;: True,
                &#39;tries&#39;: 100
            },
            &#39;description&#39;: &#39;paragraph&#39;,
            &#39;duration&#39;: &#39;small_int&#39;,
            &#39;intro&#39;: &#39;sentence&#39;,
            &#39;numSlides&#39;: &#39;small_int&#39;,
            &#39;keywords&#39;: {
                &#39;set&#39;: [&#39;engineering&#39;, &#39;mathematics&#39;, &#39;physics&#39;, &#39;chemistry&#39;, &#39;biology&#39;, &#39;computer science&#39;,
                        &#39;economics&#39;]
            }
        }

        self.gen.set_template(template)
        docs = self.gen.documents(self.iterations)

        module_res = await self.prisma.module.create_many(data=docs)

        self.modules = modules
        self.logger.info(&#39;Module model seeded successfully with %d documents!&#39; % module_res)

    async def _seedPlanOfStudyDB(self):
        &#34;&#34;&#34;
        Seeds the plan of study model with dummy data for each account already present in the DB.
        :return:
        &#34;&#34;&#34;
        self.logger.info(&#39;Seeding plan of study model...&#39;)
        plans = []

        for account in self.accounts:
            plans.append({
                &#39;studentID&#39;: account[&#39;id&#39;],
            })

        plan_res = await self.prisma.planofstudy.create_many(data=plans)

        self.plans = plans
        self.logger.info(&#39;Plan of study model seeded successfully with %d documents!&#39; % plan_res)

    async def _seedEnrollmentDB(self):
        &#34;&#34;&#34;
        Enroll each account in each module with a random role. The number of documents that will be created is equal
        to the number of plan of studies multiplied by the number of modules.
        :return: None
        &#34;&#34;&#34;
        self.logger.info(&#39;Seeding enrollment model...&#39;)
        enrollments = []

        class EnrollmentRole(Enum):
            STUDENT = 1
            TEACHER = 2
            GRADER = 3

        for pos in self.plans:
            for module in self.modules:
                enrollments.append({
                    &#39;planID&#39;: pos[&#39;id&#39;],
                    &#39;moduleId&#39;: module[&#39;id&#39;],
                    &#39;role&#39;: random.choice(list(EnrollmentRole)).name
                })

        enrollment_res = await self.prisma.moduleenrollment.create_many(data=enrollments)

        self.enrollments = enrollments
        self.logger.info(&#39;Enrollment model seeded successfully with %d documents!&#39; % enrollment_res)

    async def _seedFeedbackDB(self):
        &#34;&#34;&#34;
        Seed the feedback model with dummy data for each enrollment. The number of documents that will be created is
        equal to the number of enrollments.
        :return: None
        &#34;&#34;&#34;
        self.logger.info(&#39;Seeding feedback model...&#39;)
        feedbacks = []

        # find the user&#39;s ID given a plan ID
        plans = await self._getPlans()

        for enrollment in self.enrollments:
            feedbacks.append({
                &#39;moduleId&#39;: enrollment[&#39;moduleId&#39;],
                &#39;rating&#39;: random.randint(1, 6),
                &#39;feedback&#39;: self.gen.sentence(),
                &#39;studentId&#39;: list(map(lambda x: x[&#39;studentID&#39;], filter(lambda x: x[&#39;id&#39;] == enrollment[&#39;planID&#39;], plans))).pop()
            })

        feedback_res = await self.prisma.modulefeedback.create_many(data=feedbacks)
        self.feedbacks = feedbacks
        self.logger.info(&#39;Feedback model seeded successfully with %d documents!&#39; % feedback_res)

    async def seedAll(self):
        &#34;&#34;&#34;
        Calls all the seeding methods in the correct order. If the skip member is set to Skipper.all, then all seeding
        operations will be skipped. If the skip member is set to Skipper.&lt;modelName&gt;, then the &lt;modelName&gt; model seeding
        will be skipped.
        :return: None
        &#34;&#34;&#34;
        await self.connect()
        self.logger.info(&#39;Seeding operation started...&#39;)
        if Skipper.all in self.skip:
            self.logger.info(&#39;Skipping all model seeding...&#39;)
        else:
            if Skipper.user in self.skip:
                self.logger.info(&#39;Skipping user model seeding...&#39;)
                self.accounts = await self._getUserAccounts()
            else:
                await self._seedUserDB()

            if Skipper.module in self.skip:
                self.logger.info(&#39;Skipping module model seeding...&#39;)
                self.modules = await self._getModules()
            else:
                await self._seedModuleDB()

            if Skipper.plan in self.skip:
                self.logger.info(&#39;Skipping plan of study model seeding...&#39;)
                self.plans = await self._getPlans()
            else:
                await self._seedPlanOfStudyDB()

            if Skipper.enrollment in self.skip:
                self.logger.info(&#39;Skipping enrollment model seeding...&#39;)
                self.enrollments = await self._getEnrollments()
            else:
                await self._seedEnrollmentDB()

            if Skipper.feedback in self.skip:
                self.logger.info(&#39;Skipping feedback model seeding...&#39;)
                self.feedbacks = await self._getFeedbacks()
            else:
                await self._seedFeedbackDB()

            self.logger.info(&#39;All models seeded successfully!&#39;)
        await self.disconnect()

    async def cleanupAll(self):
        &#34;&#34;&#34;
        Calls all the cleanup methods in the correct order. If the cleanup member is set to Skipper.all, then all
        cleanup operations will be skipped. If the cleanup member is set to Skipper.&lt;modelName&gt;, then the &lt;modelName&gt;
        model cleanup will be skipped.
        :return:
        &#34;&#34;&#34;
        await self.connect()
        self.logger.info(&#39;Cleanup operation started...&#39;)

        if Skipper.all in self.cleanup:
            self.logger.info(&#39;Skipping all model cleanup...&#39;)
            return
        else:
            # Deleting all users
            if Skipper.user in self.cleanup:
                self.logger.info(&#39;Skipping user model cleanup...&#39;)
            else:
                await self._cleanupUserDB()

            # Deleting all plans of study
            if Skipper.plan in self.cleanup:
                self.logger.info(&#39;Skipping plan of study model cleanup...&#39;)
            else:
                await self._cleanupPlanOfStudyDB()

            # Deleting all enrollments
            if Skipper.enrollment in self.cleanup:
                self.logger.info(&#39;Skipping enrollment model cleanup...&#39;)
            else:
                await self._cleanupEnrollmentDB()

            # Deleting all modules
            if Skipper.module in self.cleanup:
                self.logger.info(&#39;Skipping module model cleanup...&#39;)
            else:
                await self._cleanupModuleDB()

            # Deleting all module feedback
            if Skipper.feedback in self.cleanup:
                self.logger.info(&#39;Skipping feedback model cleanup...&#39;)
            else:
                await self._cleanupFeedbackDB()

            self.logger.info(&#39;All models cleaned up successfully!&#39;)
        await self.disconnect()

    async def _cleanupUserDB(self):
        count = await self.prisma.user.delete_many()
        self.logger.info(&#39;User model cleaned up successfully! (%d documents deleted)&#39; % count)

    async def _cleanupModuleDB(self):
        count = await self.prisma.module.delete_many()
        self.logger.info(&#39;Module model cleaned up successfully! (%d documents deleted)&#39; % count)

    async def _cleanupFeedbackDB(self):
        count = await self.prisma.modulefeedback.delete_many()
        self.logger.info(&#39;Feedback model cleaned up successfully! (%d documents deleted)&#39; % count)

    async def _cleanupPlanOfStudyDB(self):
        count = await self.prisma.planofstudy.delete_many()
        self.logger.info(&#39;Plan of study model cleaned up successfully! (%d documents deleted)&#39; % count)

    async def _cleanupEnrollmentDB(self):
        count = await self.prisma.moduleenrollment.delete_many()
        self.logger.info(&#39;Enrollment model cleaned up successfully! (%d documents deleted)&#39; % count)</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="mms.utils.seed.getModuleFeedback"><code class="name flex">
<span>def <span class="ident">getModuleFeedback</span></span>(<span>)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def getModuleFeedback():
    mods = post(&#39;http://%s/graphql&#39; % os.environ.get(&#34;API_URL&#34;, &#34;localhost:4000&#34;), {}, {
        &#39;query&#39;: &#34;&#34;&#34;query{
          module(input:{}){
            id
            moduleName
            moduleNumber
            feedback{
              rating
              feedback
            }
            members{
              id
            }
          }
        }&#34;&#34;&#34;
    })
    return mods.json()[&#39;data&#39;]</code></pre>
</details>
</dd>
<dt id="mms.utils.seed.getModules"><code class="name flex">
<span>def <span class="ident">getModules</span></span>(<span>)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def getModules():
    mods = post(&#39;http://%s/graphql&#39; % os.environ.get(&#34;API_URL&#34;, &#34;localhost:4000&#34;), {}, {
        &#39;query&#39;: &#34;&#34;&#34;query{
          module(input:{}){
            id
            moduleName
            moduleNumber
          }
        }&#34;&#34;&#34;
    })
    return mods.json()[&#39;data&#39;]</code></pre>
</details>
</dd>
<dt id="mms.utils.seed.seedDbFeedback"><code class="name flex">
<span>def <span class="ident">seedDbFeedback</span></span>(<span>)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def seedDbFeedback():
    print(&#39;Seeding feedback model...&#39;)
    gen = DocumentGenerator()
    iterations = 25
    modules = getModules()[&#39;module&#39;]
    for module in modules:
        # create feedback for each module 25 times
        for i in range(iterations):
            res = post(&#39;http://%s/graphql&#39; % os.environ.get(&#34;API_URL&#34;, &#34;localhost:4000&#34;),
                       {},
                       {&#39;query&#39;: createMutationString(
                           comment=gen.sentence(),
                           rating=random.randint(1, 6),
                           moduleID=module[&#39;id&#39;],
                       )
                       })
            print(res.json())

    print(&#39;Feedback model seeded successfully!&#39;)</code></pre>
</details>
</dd>
<dt id="mms.utils.seed.seedModuleModel"><code class="name flex">
<span>def <span class="ident">seedModuleModel</span></span>(<span>)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def seedModuleModel():
    print(&#39;Seeding module model...&#39;)
    gen = DocumentGenerator()
    iterations = 25
    for i in range(iterations):
        key_length = random.randint(1, 11)
        res = post(&#39;http://%s/graphql&#39; % os.environ.get(&#34;API_URL&#34;, &#34;localhost:4000&#34;),
                   {},
                   {&#39;query&#39;: createModuleMutationString(
                       moduleName=gen.word(),
                       moduleNumber=random.randint(1, 1000),
                       description=gen.sentence(),
                       duration=random.randint(1, 100),
                       intro=gen.sentence(),
                       numSlides=random.randint(1, 100),
                       keywords=[gen.word() for i in range(key_length)]
                   )
                   })
        print(res.json())

    print(&#39;Module model seeded successfully!&#39;)</code></pre>
</details>
</dd>
<dt id="mms.utils.seed.seedPlanOfStudyDB"><code class="name flex">
<span>async def <span class="ident">seedPlanOfStudyDB</span></span>(<span>)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def seedPlanOfStudyDB():
    print(&#39;Seeding plan of study model...&#39;)
    gen = DocumentGenerator()
    prisma = Prisma()
    await prisma.connect()

    modules = await prisma.module.find_many()
    accounts = await prisma.user.find_many()

    for account in accounts:
        for module in modules:
            # create plan of study for each module 25 times
            await prisma.planofstudy.create(
                data={
                    &#34;modules&#34;: {
                        &#34;connect&#34;: {
                            &#34;id&#34;: module.get(&#39;id&#39;)
                        }
                    },
                    &#34;student&#34;: {
                        &#34;connect&#34;: {
                            &#34;id&#34;: account[&#39;id&#39;]
                        }
                    }
                }
            )

    print(&#39;Plan of study model seeded successfully!&#39;)</code></pre>
</details>
</dd>
<dt id="mms.utils.seed.seedUserDB"><code class="name flex">
<span>async def <span class="ident">seedUserDB</span></span>(<span>)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def seedUserDB():
    print(&#39;Seeding user model...&#39;)
    prisma = Prisma()
    await prisma.connect()
    gen = DocumentGenerator()
    iterations = 25
    accounts = []

    for i in range(iterations):
        accounts.append({
            &#39;firstName&#39;: gen.name(),
            &#39;lastName&#39;: gen.name(),
            &#39;email&#39;: gen.email(),
            &#39;openID&#39;: str(gen.integer()),
        })

    users = await prisma.user.create_many(data=accounts)

    print(&#39;User model seeded successfully with %d documents!&#39; % users)
    await prisma.disconnect()</code></pre>
</details>
</dd>
</dl>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="mms.utils.seed.Seeder"><code class="flex name class">
<span>class <span class="ident">Seeder</span></span>
<span>(</span><span>skip: [<enum '<a title="mms.utils.seed.Skipper" href="#mms.utils.seed.Skipper">Skipper</a>'>] = None, cleanup: [<enum '<a title="mms.utils.seed.Skipper" href="#mms.utils.seed.Skipper">Skipper</a>'>] = None, iterations: int = 25)</span>
</code></dt>
<dd>
<div class="desc"><p>Seeder class for seeding the database with dummy data. Makes use of the prisma python client to connection to the
database and the essential_generators library to create document templates.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Seeder:
    &#34;&#34;&#34;
    Seeder class for seeding the database with dummy data. Makes use of the prisma python client to connection to the
    database and the essential_generators library to create document templates.
    &#34;&#34;&#34;

    def __init__(self, skip: [Skipper] = None, cleanup: [Skipper] = None, iterations: int = 25):
        self.gen = DocumentGenerator()
        self.gen.init_word_cache(5000)
        self.gen.init_sentence_cache(5000)
        self.prisma = Prisma()
        self.iterations = iterations
        self.accounts = []
        self.modules = []
        self.enrollments = []
        self.feedbacks = []
        self.plans = []
        self.skip = skip
        self.cleanup = cleanup
        self.logger = logging.getLogger(&#39;__seed__&#39;)
        logging.basicConfig(format=&#39;%(levelname)s:%(message)s&#39;, level=logging.INFO)

    async def connect(self):
        &#34;&#34;&#34;
        Connects to the database using prisma client.
        &#34;&#34;&#34;
        await self.prisma.connect()

    async def disconnect(self):
        &#34;&#34;&#34;
        Disconnects from the database using prisma client.
        &#34;&#34;&#34;
        await self.prisma.disconnect()

    async def _getUserAccounts(self):
        &#34;&#34;&#34;
        Gets all user accounts from the database and returns them as a list of dictionaries.
        :return: class&lt;list&gt; of class&lt;dict&gt; of type&lt;User&gt;
        &#34;&#34;&#34;
        accounts = await self.prisma.user.find_many()

        acc = []

        for i in range(len(accounts)):
            acc.append(accounts[i].dict())

        return acc

    async def _getModules(self):
        &#34;&#34;&#34;
        Gets all modules from the database and returns them as a list of dictionaries.
        :return: class&lt;list&gt; of class&lt;dict&gt; of type&lt;Module&gt;
        &#34;&#34;&#34;
        self.modules = await self.prisma.module.find_many()

        mods = []

        for i in range(len(self.modules)):
            mods.append(self.modules[i].dict())

        return mods

    async def _getEnrollments(self):
        &#34;&#34;&#34;
        Gets all enrollments from the database and returns them as a list of dictionaries.
        :return: class&lt;list&gt; of class&lt;dict&gt; of type&lt;ModuleEnrollment&gt;
        &#34;&#34;&#34;
        self.enrollments = await self.prisma.moduleenrollment.find_many()

        enrollments = []

        for i in range(len(self.enrollments)):
            enrollments.append(self.enrollments[i].dict())

        return enrollments

    async def _getFeedbacks(self):
        &#34;&#34;&#34;
        Gets all feedbacks from the database and returns them as a list of dictionaries.
        :return: class&lt;list&gt; of class&lt;dict&gt; of type&lt;ModuleFeedback&gt;
        &#34;&#34;&#34;
        self.feedbacks = await self.prisma.modulefeedback.find_many()

        feedbacks = []

        for i in range(len(self.feedbacks)):
            feedbacks.append(self.feedbacks[i].dict())

        return feedbacks

    async def _getPlans(self) -&gt; list[dict]:
        self.plans = await self.prisma.planofstudy.find_many()

        plans = []

        for i in range(len(self.plans)):
            plans.append(self.plans[i].dict())

        return plans

    async def _seedUserDB(self):
        &#34;&#34;&#34;
        Seeds the user model with dummy data as many times as described by the iterations&#39; member.
        :return: None
        &#34;&#34;&#34;
        self.logger.info(&#39;Seeding user model...&#39;)
        accounts = []

        for i in range(self.iterations):
            accounts.append({
                &#39;firstName&#39;: self.gen.name(),
                &#39;lastName&#39;: self.gen.name(),
                &#39;email&#39;: self.gen.email(),
                &#39;openID&#39;: str(self.gen.integer()),
            })

        users = await self.prisma.user.create_many(data=accounts)

        self.accounts = accounts
        self.logger.info(&#39;User model seeded successfully with %d documents!&#39; % users)

    async def _seedModuleDB(self):
        &#34;&#34;&#34;
        Seeds the module model with dummy data as many times as described by the iterations&#39; member.
        :return: None
        &#34;&#34;&#34;
        self.logger.info(&#39;Seeding module model...&#39;)
        modules = []

        template = {
            &#39;moduleName&#39;: {
                &#39;typemap&#39;: &#39;sentence&#39;,
                &#39;unique&#39;: True,
                &#39;tries&#39;: 100
            },
            &#39;moduleNumber&#39;: {
                &#39;typemap&#39;: &#39;integer&#39;,
                &#39;unique&#39;: True,
                &#39;tries&#39;: 100
            },
            &#39;description&#39;: &#39;paragraph&#39;,
            &#39;duration&#39;: &#39;small_int&#39;,
            &#39;intro&#39;: &#39;sentence&#39;,
            &#39;numSlides&#39;: &#39;small_int&#39;,
            &#39;keywords&#39;: {
                &#39;set&#39;: [&#39;engineering&#39;, &#39;mathematics&#39;, &#39;physics&#39;, &#39;chemistry&#39;, &#39;biology&#39;, &#39;computer science&#39;,
                        &#39;economics&#39;]
            }
        }

        self.gen.set_template(template)
        docs = self.gen.documents(self.iterations)

        module_res = await self.prisma.module.create_many(data=docs)

        self.modules = modules
        self.logger.info(&#39;Module model seeded successfully with %d documents!&#39; % module_res)

    async def _seedPlanOfStudyDB(self):
        &#34;&#34;&#34;
        Seeds the plan of study model with dummy data for each account already present in the DB.
        :return:
        &#34;&#34;&#34;
        self.logger.info(&#39;Seeding plan of study model...&#39;)
        plans = []

        for account in self.accounts:
            plans.append({
                &#39;studentID&#39;: account[&#39;id&#39;],
            })

        plan_res = await self.prisma.planofstudy.create_many(data=plans)

        self.plans = plans
        self.logger.info(&#39;Plan of study model seeded successfully with %d documents!&#39; % plan_res)

    async def _seedEnrollmentDB(self):
        &#34;&#34;&#34;
        Enroll each account in each module with a random role. The number of documents that will be created is equal
        to the number of plan of studies multiplied by the number of modules.
        :return: None
        &#34;&#34;&#34;
        self.logger.info(&#39;Seeding enrollment model...&#39;)
        enrollments = []

        class EnrollmentRole(Enum):
            STUDENT = 1
            TEACHER = 2
            GRADER = 3

        for pos in self.plans:
            for module in self.modules:
                enrollments.append({
                    &#39;planID&#39;: pos[&#39;id&#39;],
                    &#39;moduleId&#39;: module[&#39;id&#39;],
                    &#39;role&#39;: random.choice(list(EnrollmentRole)).name
                })

        enrollment_res = await self.prisma.moduleenrollment.create_many(data=enrollments)

        self.enrollments = enrollments
        self.logger.info(&#39;Enrollment model seeded successfully with %d documents!&#39; % enrollment_res)

    async def _seedFeedbackDB(self):
        &#34;&#34;&#34;
        Seed the feedback model with dummy data for each enrollment. The number of documents that will be created is
        equal to the number of enrollments.
        :return: None
        &#34;&#34;&#34;
        self.logger.info(&#39;Seeding feedback model...&#39;)
        feedbacks = []

        # find the user&#39;s ID given a plan ID
        plans = await self._getPlans()

        for enrollment in self.enrollments:
            feedbacks.append({
                &#39;moduleId&#39;: enrollment[&#39;moduleId&#39;],
                &#39;rating&#39;: random.randint(1, 6),
                &#39;feedback&#39;: self.gen.sentence(),
                &#39;studentId&#39;: list(map(lambda x: x[&#39;studentID&#39;], filter(lambda x: x[&#39;id&#39;] == enrollment[&#39;planID&#39;], plans))).pop()
            })

        feedback_res = await self.prisma.modulefeedback.create_many(data=feedbacks)
        self.feedbacks = feedbacks
        self.logger.info(&#39;Feedback model seeded successfully with %d documents!&#39; % feedback_res)

    async def seedAll(self):
        &#34;&#34;&#34;
        Calls all the seeding methods in the correct order. If the skip member is set to Skipper.all, then all seeding
        operations will be skipped. If the skip member is set to Skipper.&lt;modelName&gt;, then the &lt;modelName&gt; model seeding
        will be skipped.
        :return: None
        &#34;&#34;&#34;
        await self.connect()
        self.logger.info(&#39;Seeding operation started...&#39;)
        if Skipper.all in self.skip:
            self.logger.info(&#39;Skipping all model seeding...&#39;)
        else:
            if Skipper.user in self.skip:
                self.logger.info(&#39;Skipping user model seeding...&#39;)
                self.accounts = await self._getUserAccounts()
            else:
                await self._seedUserDB()

            if Skipper.module in self.skip:
                self.logger.info(&#39;Skipping module model seeding...&#39;)
                self.modules = await self._getModules()
            else:
                await self._seedModuleDB()

            if Skipper.plan in self.skip:
                self.logger.info(&#39;Skipping plan of study model seeding...&#39;)
                self.plans = await self._getPlans()
            else:
                await self._seedPlanOfStudyDB()

            if Skipper.enrollment in self.skip:
                self.logger.info(&#39;Skipping enrollment model seeding...&#39;)
                self.enrollments = await self._getEnrollments()
            else:
                await self._seedEnrollmentDB()

            if Skipper.feedback in self.skip:
                self.logger.info(&#39;Skipping feedback model seeding...&#39;)
                self.feedbacks = await self._getFeedbacks()
            else:
                await self._seedFeedbackDB()

            self.logger.info(&#39;All models seeded successfully!&#39;)
        await self.disconnect()

    async def cleanupAll(self):
        &#34;&#34;&#34;
        Calls all the cleanup methods in the correct order. If the cleanup member is set to Skipper.all, then all
        cleanup operations will be skipped. If the cleanup member is set to Skipper.&lt;modelName&gt;, then the &lt;modelName&gt;
        model cleanup will be skipped.
        :return:
        &#34;&#34;&#34;
        await self.connect()
        self.logger.info(&#39;Cleanup operation started...&#39;)

        if Skipper.all in self.cleanup:
            self.logger.info(&#39;Skipping all model cleanup...&#39;)
            return
        else:
            # Deleting all users
            if Skipper.user in self.cleanup:
                self.logger.info(&#39;Skipping user model cleanup...&#39;)
            else:
                await self._cleanupUserDB()

            # Deleting all plans of study
            if Skipper.plan in self.cleanup:
                self.logger.info(&#39;Skipping plan of study model cleanup...&#39;)
            else:
                await self._cleanupPlanOfStudyDB()

            # Deleting all enrollments
            if Skipper.enrollment in self.cleanup:
                self.logger.info(&#39;Skipping enrollment model cleanup...&#39;)
            else:
                await self._cleanupEnrollmentDB()

            # Deleting all modules
            if Skipper.module in self.cleanup:
                self.logger.info(&#39;Skipping module model cleanup...&#39;)
            else:
                await self._cleanupModuleDB()

            # Deleting all module feedback
            if Skipper.feedback in self.cleanup:
                self.logger.info(&#39;Skipping feedback model cleanup...&#39;)
            else:
                await self._cleanupFeedbackDB()

            self.logger.info(&#39;All models cleaned up successfully!&#39;)
        await self.disconnect()

    async def _cleanupUserDB(self):
        count = await self.prisma.user.delete_many()
        self.logger.info(&#39;User model cleaned up successfully! (%d documents deleted)&#39; % count)

    async def _cleanupModuleDB(self):
        count = await self.prisma.module.delete_many()
        self.logger.info(&#39;Module model cleaned up successfully! (%d documents deleted)&#39; % count)

    async def _cleanupFeedbackDB(self):
        count = await self.prisma.modulefeedback.delete_many()
        self.logger.info(&#39;Feedback model cleaned up successfully! (%d documents deleted)&#39; % count)

    async def _cleanupPlanOfStudyDB(self):
        count = await self.prisma.planofstudy.delete_many()
        self.logger.info(&#39;Plan of study model cleaned up successfully! (%d documents deleted)&#39; % count)

    async def _cleanupEnrollmentDB(self):
        count = await self.prisma.moduleenrollment.delete_many()
        self.logger.info(&#39;Enrollment model cleaned up successfully! (%d documents deleted)&#39; % count)</code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="mms.utils.seed.Seeder.cleanupAll"><code class="name flex">
<span>async def <span class="ident">cleanupAll</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Calls all the cleanup methods in the correct order. If the cleanup member is set to Skipper.all, then all
cleanup operations will be skipped. If the cleanup member is set to Skipper.<modelName>, then the <modelName>
model cleanup will be skipped.
:return:</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def cleanupAll(self):
    &#34;&#34;&#34;
    Calls all the cleanup methods in the correct order. If the cleanup member is set to Skipper.all, then all
    cleanup operations will be skipped. If the cleanup member is set to Skipper.&lt;modelName&gt;, then the &lt;modelName&gt;
    model cleanup will be skipped.
    :return:
    &#34;&#34;&#34;
    await self.connect()
    self.logger.info(&#39;Cleanup operation started...&#39;)

    if Skipper.all in self.cleanup:
        self.logger.info(&#39;Skipping all model cleanup...&#39;)
        return
    else:
        # Deleting all users
        if Skipper.user in self.cleanup:
            self.logger.info(&#39;Skipping user model cleanup...&#39;)
        else:
            await self._cleanupUserDB()

        # Deleting all plans of study
        if Skipper.plan in self.cleanup:
            self.logger.info(&#39;Skipping plan of study model cleanup...&#39;)
        else:
            await self._cleanupPlanOfStudyDB()

        # Deleting all enrollments
        if Skipper.enrollment in self.cleanup:
            self.logger.info(&#39;Skipping enrollment model cleanup...&#39;)
        else:
            await self._cleanupEnrollmentDB()

        # Deleting all modules
        if Skipper.module in self.cleanup:
            self.logger.info(&#39;Skipping module model cleanup...&#39;)
        else:
            await self._cleanupModuleDB()

        # Deleting all module feedback
        if Skipper.feedback in self.cleanup:
            self.logger.info(&#39;Skipping feedback model cleanup...&#39;)
        else:
            await self._cleanupFeedbackDB()

        self.logger.info(&#39;All models cleaned up successfully!&#39;)
    await self.disconnect()</code></pre>
</details>
</dd>
<dt id="mms.utils.seed.Seeder.connect"><code class="name flex">
<span>async def <span class="ident">connect</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Connects to the database using prisma client.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def connect(self):
    &#34;&#34;&#34;
    Connects to the database using prisma client.
    &#34;&#34;&#34;
    await self.prisma.connect()</code></pre>
</details>
</dd>
<dt id="mms.utils.seed.Seeder.disconnect"><code class="name flex">
<span>async def <span class="ident">disconnect</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Disconnects from the database using prisma client.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def disconnect(self):
    &#34;&#34;&#34;
    Disconnects from the database using prisma client.
    &#34;&#34;&#34;
    await self.prisma.disconnect()</code></pre>
</details>
</dd>
<dt id="mms.utils.seed.Seeder.seedAll"><code class="name flex">
<span>async def <span class="ident">seedAll</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Calls all the seeding methods in the correct order. If the skip member is set to Skipper.all, then all seeding
operations will be skipped. If the skip member is set to Skipper.<modelName>, then the <modelName> model seeding
will be skipped.
:return: None</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def seedAll(self):
    &#34;&#34;&#34;
    Calls all the seeding methods in the correct order. If the skip member is set to Skipper.all, then all seeding
    operations will be skipped. If the skip member is set to Skipper.&lt;modelName&gt;, then the &lt;modelName&gt; model seeding
    will be skipped.
    :return: None
    &#34;&#34;&#34;
    await self.connect()
    self.logger.info(&#39;Seeding operation started...&#39;)
    if Skipper.all in self.skip:
        self.logger.info(&#39;Skipping all model seeding...&#39;)
    else:
        if Skipper.user in self.skip:
            self.logger.info(&#39;Skipping user model seeding...&#39;)
            self.accounts = await self._getUserAccounts()
        else:
            await self._seedUserDB()

        if Skipper.module in self.skip:
            self.logger.info(&#39;Skipping module model seeding...&#39;)
            self.modules = await self._getModules()
        else:
            await self._seedModuleDB()

        if Skipper.plan in self.skip:
            self.logger.info(&#39;Skipping plan of study model seeding...&#39;)
            self.plans = await self._getPlans()
        else:
            await self._seedPlanOfStudyDB()

        if Skipper.enrollment in self.skip:
            self.logger.info(&#39;Skipping enrollment model seeding...&#39;)
            self.enrollments = await self._getEnrollments()
        else:
            await self._seedEnrollmentDB()

        if Skipper.feedback in self.skip:
            self.logger.info(&#39;Skipping feedback model seeding...&#39;)
            self.feedbacks = await self._getFeedbacks()
        else:
            await self._seedFeedbackDB()

        self.logger.info(&#39;All models seeded successfully!&#39;)
    await self.disconnect()</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="mms.utils.seed.Skipper"><code class="flex name class">
<span>class <span class="ident">Skipper</span></span>
<span>(</span><span>value, names=None, *, module=None, qualname=None, type=None, start=1)</span>
</code></dt>
<dd>
<div class="desc"><p>An enumeration.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Skipper(Enum):
    user = 1
    module = 2
    feedback = 3
    plan = 4
    enrollment = 5
    all = 6</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>enum.Enum</li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="mms.utils.seed.Skipper.all"><code class="name">var <span class="ident">all</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="mms.utils.seed.Skipper.enrollment"><code class="name">var <span class="ident">enrollment</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="mms.utils.seed.Skipper.feedback"><code class="name">var <span class="ident">feedback</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="mms.utils.seed.Skipper.module"><code class="name">var <span class="ident">module</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="mms.utils.seed.Skipper.plan"><code class="name">var <span class="ident">plan</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="mms.utils.seed.Skipper.user"><code class="name">var <span class="ident">user</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="mms.utils" href="index.html">mms.utils</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="two-column">
<li><code><a title="mms.utils.seed.getModuleFeedback" href="#mms.utils.seed.getModuleFeedback">getModuleFeedback</a></code></li>
<li><code><a title="mms.utils.seed.getModules" href="#mms.utils.seed.getModules">getModules</a></code></li>
<li><code><a title="mms.utils.seed.seedDbFeedback" href="#mms.utils.seed.seedDbFeedback">seedDbFeedback</a></code></li>
<li><code><a title="mms.utils.seed.seedModuleModel" href="#mms.utils.seed.seedModuleModel">seedModuleModel</a></code></li>
<li><code><a title="mms.utils.seed.seedPlanOfStudyDB" href="#mms.utils.seed.seedPlanOfStudyDB">seedPlanOfStudyDB</a></code></li>
<li><code><a title="mms.utils.seed.seedUserDB" href="#mms.utils.seed.seedUserDB">seedUserDB</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="mms.utils.seed.Seeder" href="#mms.utils.seed.Seeder">Seeder</a></code></h4>
<ul class="">
<li><code><a title="mms.utils.seed.Seeder.cleanupAll" href="#mms.utils.seed.Seeder.cleanupAll">cleanupAll</a></code></li>
<li><code><a title="mms.utils.seed.Seeder.connect" href="#mms.utils.seed.Seeder.connect">connect</a></code></li>
<li><code><a title="mms.utils.seed.Seeder.disconnect" href="#mms.utils.seed.Seeder.disconnect">disconnect</a></code></li>
<li><code><a title="mms.utils.seed.Seeder.seedAll" href="#mms.utils.seed.Seeder.seedAll">seedAll</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="mms.utils.seed.Skipper" href="#mms.utils.seed.Skipper">Skipper</a></code></h4>
<ul class="two-column">
<li><code><a title="mms.utils.seed.Skipper.all" href="#mms.utils.seed.Skipper.all">all</a></code></li>
<li><code><a title="mms.utils.seed.Skipper.enrollment" href="#mms.utils.seed.Skipper.enrollment">enrollment</a></code></li>
<li><code><a title="mms.utils.seed.Skipper.feedback" href="#mms.utils.seed.Skipper.feedback">feedback</a></code></li>
<li><code><a title="mms.utils.seed.Skipper.module" href="#mms.utils.seed.Skipper.module">module</a></code></li>
<li><code><a title="mms.utils.seed.Skipper.plan" href="#mms.utils.seed.Skipper.plan">plan</a></code></li>
<li><code><a title="mms.utils.seed.Skipper.user" href="#mms.utils.seed.Skipper.user">user</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>