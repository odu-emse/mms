<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>emse-mms.models.meta API documentation</title>
<meta name="description" content="" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>emse-mms.models.meta</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">import pandas as pd
from nltk.corpus import stopwords
from sklearn.feature_extraction.text import CountVectorizer
from sklearn.metrics.pairwise import cosine_similarity


class MetaRecommender:
    &#34;&#34;&#34;
    This class is used to recommend modules based on the module name, description, keywords and objectives. This is commonly
    referred to as a Meta-Based Recommender System. The class takes in a path to a json file, a target module name and a
    size of the recommendation list. The class will then return a list of
    recommended modules based on the target module name.
    &#34;&#34;&#34;

    def __init__(self, path: str, target: str, size: int = 10):
        self.df = pd.read_json(path)
        self.featureDf = pd.DataFrame()
        self.target = target
        self.stop = stopwords.words(&#34;english&#34;)
        self.cv = CountVectorizer()
        self.similarity = None
        self.size = size

    @staticmethod
    def _convert_module_id(df: pd.DataFrame()):
        &#34;&#34;&#34;
        This function is used to convert the module id from a mongo Object ID to a string.
        :param df: the dataframe to be modified by the apply function
        :return: the modified dataframe
        &#34;&#34;&#34;
        temp_id = df[&#34;id&#34;]
        temp_id = dict(temp_id)
        temp_id = temp_id[&#34;$oid&#34;]
        df[&#34;_id&#34;] = temp_id
        return df

    @staticmethod
    def _scalar_to_str(df: pd.DataFrame()):
        lst_k = list(df[&#34;keywords&#34;])
        lst_o = list(df[&#34;objectives&#34;])

        str_key_feat = &#34;&#34;
        str_obj_feat = &#34;&#34;

        for key in lst_k:
            str_key_feat += str(key) + &#34; &#34;

        for obj in lst_o:
            str_obj_feat += str(obj) + &#34; &#34;

        df[&#34;keywords&#34;] = str_key_feat
        df[&#34;objectives&#34;] = str_obj_feat
        return df

    def _clean_data(self, cleanID, cleanScalar):
        self.df = self.df.apply(cleanID, axis=1)
        self.df = self.df.drop([&#34;id&#34;], axis=1)
        self.df = self.df.reset_index(drop=True)

        self.df = self.df.apply(cleanScalar, axis=1)

    def _create_features(self):
        features = []

        for i in range(0, self.df.shape[0]):
            features.append(
                self.df[&#34;moduleName&#34;][i]
                + &#34; &#34;
                + self.df[&#34;intro&#34;][i]
                + &#34; &#34;
                + self.df[&#34;description&#34;][i]
                + &#34; &#34;
                + self.df[&#34;keywords&#34;][i]
                + &#34; &#34;
                + self.df[&#34;objectives&#34;][i]
            )
        self.df[&#34;features&#34;] = features
        self.df.insert(1, &#34;id&#34;, list(range(1, len(self.df) + 1)), True)

    def _text_processing(self, col: pd.DataFrame()):
        column = col.str.lower()
        column = column.str.replace(&#34;[^a-z ]&#34;, &#34;&#34;)
        word_tokens = column.str.split()
        keys = word_tokens.apply(
            lambda x: [item for item in x if item not in self.stop]
        )
        for i in range(len(keys)):
            keys[i] = &#34; &#34;.join(keys[i])
            column = keys
        return column

    def _get_cosine(self):
        count_matrix = self.cv.fit_transform(self.featureDf[&#34;cleaned_features&#34;])
        self.similarity = cosine_similarity(count_matrix)

    def _get_recommendations(self):
        try:
            module_id = self.df[
                self.df[&#34;moduleName&#34;].str.lower() == str(self.target).lower()
            ][&#34;id&#34;].values[0]
            score = list(enumerate(self.similarity[module_id]))

            sorted_score = sorted(score, key=lambda x: x[1], reverse=True)

            sorted_score = sorted_score[1:]

            if self.size &gt; len(sorted_score):
                self.size = len(sorted_score)

            results = []

            i = 0
            for item in sorted_score:
                module_title = self.df[self.df[&#34;id&#34;] == item[0]][&#34;moduleName&#34;].values[0]
                module_oid = self.df[self.df[&#34;id&#34;] == item[0]][&#34;_id&#34;].values[0]
                print(i + 1, module_title, module_oid, item[1])
                results.append(
                    {&#34;title&#34;: module_title, &#34;id&#34;: module_oid, &#34;score&#34;: item[1]}
                )
                i += 1
                if i &gt; self.size - 1:
                    break

            return results
        except IndexError:
            return {&#34;error&#34;: &#34;Module not found&#34;}

    def run(self):
        &#34;&#34;&#34;
        This function is used to run the recommender system. It recommends modules based on the
        target module name passed in. The list will be sorted by the cosine similarity score.
        The list will be in the format of

        *[{&#34;title&#34;: module_title, &#34;id&#34;: module_oid, &#34;score&#34;: cosine_similarity_score}, ...]*

        .. todo:: Add a check to see if the target module name is in the database.

        .. return:: a list of recommended modules or a dictionary an error message
        &#34;&#34;&#34;
        self._clean_data(self._convert_module_id, self._scalar_to_str)
        self._create_features()
        self.featureDf = self.df[[&#34;id&#34;, &#34;features&#34;]]
        self.featureDf[&#34;cleaned_features&#34;] = self._text_processing(
            self.featureDf[&#34;features&#34;]
        )

        self._get_cosine()

        return self._get_recommendations()</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="emse-mms.models.meta.MetaRecommender"><code class="flex name class">
<span>class <span class="ident">MetaRecommender</span></span>
<span>(</span><span>path: str, target: str, size: int = 10)</span>
</code></dt>
<dd>
<div class="desc"><p>This class is used to recommend modules based on the module name, description, keywords and objectives. This is commonly
referred to as a Meta-Based Recommender System. The class takes in a path to a json file, a target module name and a
size of the recommendation list. The class will then return a list of
recommended modules based on the target module name.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class MetaRecommender:
    &#34;&#34;&#34;
    This class is used to recommend modules based on the module name, description, keywords and objectives. This is commonly
    referred to as a Meta-Based Recommender System. The class takes in a path to a json file, a target module name and a
    size of the recommendation list. The class will then return a list of
    recommended modules based on the target module name.
    &#34;&#34;&#34;

    def __init__(self, path: str, target: str, size: int = 10):
        self.df = pd.read_json(path)
        self.featureDf = pd.DataFrame()
        self.target = target
        self.stop = stopwords.words(&#34;english&#34;)
        self.cv = CountVectorizer()
        self.similarity = None
        self.size = size

    @staticmethod
    def _convert_module_id(df: pd.DataFrame()):
        &#34;&#34;&#34;
        This function is used to convert the module id from a mongo Object ID to a string.
        :param df: the dataframe to be modified by the apply function
        :return: the modified dataframe
        &#34;&#34;&#34;
        temp_id = df[&#34;id&#34;]
        temp_id = dict(temp_id)
        temp_id = temp_id[&#34;$oid&#34;]
        df[&#34;_id&#34;] = temp_id
        return df

    @staticmethod
    def _scalar_to_str(df: pd.DataFrame()):
        lst_k = list(df[&#34;keywords&#34;])
        lst_o = list(df[&#34;objectives&#34;])

        str_key_feat = &#34;&#34;
        str_obj_feat = &#34;&#34;

        for key in lst_k:
            str_key_feat += str(key) + &#34; &#34;

        for obj in lst_o:
            str_obj_feat += str(obj) + &#34; &#34;

        df[&#34;keywords&#34;] = str_key_feat
        df[&#34;objectives&#34;] = str_obj_feat
        return df

    def _clean_data(self, cleanID, cleanScalar):
        self.df = self.df.apply(cleanID, axis=1)
        self.df = self.df.drop([&#34;id&#34;], axis=1)
        self.df = self.df.reset_index(drop=True)

        self.df = self.df.apply(cleanScalar, axis=1)

    def _create_features(self):
        features = []

        for i in range(0, self.df.shape[0]):
            features.append(
                self.df[&#34;moduleName&#34;][i]
                + &#34; &#34;
                + self.df[&#34;intro&#34;][i]
                + &#34; &#34;
                + self.df[&#34;description&#34;][i]
                + &#34; &#34;
                + self.df[&#34;keywords&#34;][i]
                + &#34; &#34;
                + self.df[&#34;objectives&#34;][i]
            )
        self.df[&#34;features&#34;] = features
        self.df.insert(1, &#34;id&#34;, list(range(1, len(self.df) + 1)), True)

    def _text_processing(self, col: pd.DataFrame()):
        column = col.str.lower()
        column = column.str.replace(&#34;[^a-z ]&#34;, &#34;&#34;)
        word_tokens = column.str.split()
        keys = word_tokens.apply(
            lambda x: [item for item in x if item not in self.stop]
        )
        for i in range(len(keys)):
            keys[i] = &#34; &#34;.join(keys[i])
            column = keys
        return column

    def _get_cosine(self):
        count_matrix = self.cv.fit_transform(self.featureDf[&#34;cleaned_features&#34;])
        self.similarity = cosine_similarity(count_matrix)

    def _get_recommendations(self):
        try:
            module_id = self.df[
                self.df[&#34;moduleName&#34;].str.lower() == str(self.target).lower()
            ][&#34;id&#34;].values[0]
            score = list(enumerate(self.similarity[module_id]))

            sorted_score = sorted(score, key=lambda x: x[1], reverse=True)

            sorted_score = sorted_score[1:]

            if self.size &gt; len(sorted_score):
                self.size = len(sorted_score)

            results = []

            i = 0
            for item in sorted_score:
                module_title = self.df[self.df[&#34;id&#34;] == item[0]][&#34;moduleName&#34;].values[0]
                module_oid = self.df[self.df[&#34;id&#34;] == item[0]][&#34;_id&#34;].values[0]
                print(i + 1, module_title, module_oid, item[1])
                results.append(
                    {&#34;title&#34;: module_title, &#34;id&#34;: module_oid, &#34;score&#34;: item[1]}
                )
                i += 1
                if i &gt; self.size - 1:
                    break

            return results
        except IndexError:
            return {&#34;error&#34;: &#34;Module not found&#34;}

    def run(self):
        &#34;&#34;&#34;
        This function is used to run the recommender system. It recommends modules based on the
        target module name passed in. The list will be sorted by the cosine similarity score.
        The list will be in the format of

        *[{&#34;title&#34;: module_title, &#34;id&#34;: module_oid, &#34;score&#34;: cosine_similarity_score}, ...]*

        .. todo:: Add a check to see if the target module name is in the database.

        .. return:: a list of recommended modules or a dictionary an error message
        &#34;&#34;&#34;
        self._clean_data(self._convert_module_id, self._scalar_to_str)
        self._create_features()
        self.featureDf = self.df[[&#34;id&#34;, &#34;features&#34;]]
        self.featureDf[&#34;cleaned_features&#34;] = self._text_processing(
            self.featureDf[&#34;features&#34;]
        )

        self._get_cosine()

        return self._get_recommendations()</code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="emse-mms.models.meta.MetaRecommender.run"><code class="name flex">
<span>def <span class="ident">run</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>This function is used to run the recommender system. It recommends modules based on the
target module name passed in. The list will be sorted by the cosine similarity score.
The list will be in the format of</p>
<p><em>[{"title": module_title, "id": module_oid, "score": cosine_similarity_score}, &hellip;]</em></p>
<div class="admonition todo">
<p class="admonition-title">TODO</p>
<p>Add a check to see if the target module name is in the database.</p>
</div>
<div class="admonition return">
<p class="admonition-title">Return:&ensp;a list of recommended modules or a dictionary an error message</p>
</div></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def run(self):
    &#34;&#34;&#34;
    This function is used to run the recommender system. It recommends modules based on the
    target module name passed in. The list will be sorted by the cosine similarity score.
    The list will be in the format of

    *[{&#34;title&#34;: module_title, &#34;id&#34;: module_oid, &#34;score&#34;: cosine_similarity_score}, ...]*

    .. todo:: Add a check to see if the target module name is in the database.

    .. return:: a list of recommended modules or a dictionary an error message
    &#34;&#34;&#34;
    self._clean_data(self._convert_module_id, self._scalar_to_str)
    self._create_features()
    self.featureDf = self.df[[&#34;id&#34;, &#34;features&#34;]]
    self.featureDf[&#34;cleaned_features&#34;] = self._text_processing(
        self.featureDf[&#34;features&#34;]
    )

    self._get_cosine()

    return self._get_recommendations()</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="emse-mms.models" href="index.html">emse-mms.models</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="emse-mms.models.meta.MetaRecommender" href="#emse-mms.models.meta.MetaRecommender">MetaRecommender</a></code></h4>
<ul class="">
<li><code><a title="emse-mms.models.meta.MetaRecommender.run" href="#emse-mms.models.meta.MetaRecommender.run">run</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>