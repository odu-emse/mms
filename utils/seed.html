<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>emse-mms.utils.seed API documentation</title>
<meta name="description" content="" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>emse-mms.utils.seed</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">import asyncio
import csv
from enum import Enum
import os
from typing import Union
from string import Template

import numpy as np
from essential_generators import DocumentGenerator
from prisma import Prisma
import logging
from requests import post, Response


def getModuleFeedback():
    mods = post(&#39;http://%s/graphql&#39; % os.environ.get(&#34;API_URL&#34;, &#34;client:4000&#34;), {}, {
        &#39;query&#39;: &#34;&#34;&#34;query{
          module(input:{}){
            id
            moduleName
            moduleNumber
            feedback{
              rating
              feedback
            }
            members{
              id
            }
          }
        }&#34;&#34;&#34;
    })
    return mods.json()[&#39;data&#39;]


class Skipper(Enum):
    user = 1
    module = 2
    feedback = 3
    plan = 4
    enrollment = 5
    all = 6


class Seeder:
    &#34;&#34;&#34;
    Seeder class for seeding the database with dummy data. Makes use of the prisma python client to connection to the
    database and the essential_generators library to create document templates.
    &#34;&#34;&#34;

    def __init__(self, skip: [Skipper] = None, cleanup: [Skipper] = None, iterations: int = 25,
                 target: Union[str, None] = None):
        self.gen = DocumentGenerator()
        self.gen.init_word_cache(5000)
        self.gen.init_sentence_cache(5000)
        self.prisma = Prisma()
        self.iterations = iterations
        self.accounts = []
        self.modules = []
        self.enrollments = []
        self.feedbacks = []
        self.plans = []
        self.skip = skip
        self.cleanup = cleanup
        self.target = target
        self.logger = logging.getLogger(&#39;__seed__&#39;)
        logging.basicConfig(format=&#39;%(levelname)s:%(message)s&#39;, level=logging.INFO)

    async def connect(self):
        &#34;&#34;&#34;
        Connects to the database using prisma client.
        &#34;&#34;&#34;
        await self.prisma.connect()

    async def disconnect(self):
        &#34;&#34;&#34;
        Disconnects from the database using prisma client.
        &#34;&#34;&#34;
        await self.prisma.disconnect()

    async def createTargetUser(self):
        &#34;&#34;&#34;
        Creates a target user for testing purposes.
        &#34;&#34;&#34;
        account = await self.prisma.user.create(data={
            &#39;firstName&#39;: &#39;Test User&#39;,
            &#39;lastName&#39;: &#39;Test User&#39;,
            &#39;email&#39;: &#39;&#39;,
            &#39;openID&#39;: &#39;&#39;
        })

        self.logger.info(&#39;Created target user: %s&#39; % account.id)
        return account.id

    async def _getUserAccounts(self):
        &#34;&#34;&#34;
        Gets all user accounts from the database and returns them as a list of dictionaries.
        :return: class&lt;list&gt; of class&lt;dict&gt; of type&lt;User&gt;
        &#34;&#34;&#34;
        accounts = await self.prisma.user.find_many()

        acc = []

        for i in range(len(accounts)):
            acc.append(accounts[i].dict())

        return acc

    async def _getModules(self):
        &#34;&#34;&#34;
        Gets all modules from the database and returns them as a list of dictionaries.
        :return: class&lt;list&gt; of class&lt;dict&gt; of type&lt;Module&gt;
        &#34;&#34;&#34;
        self.modules = await self.prisma.module.find_many()

        mods = []

        for i in range(len(self.modules)):
            mods.append(self.modules[i].dict())

        return mods

    async def _getEnrollments(self):
        &#34;&#34;&#34;
        Gets all enrollments from the database and returns them as a list of dictionaries.
        :return: class&lt;list&gt; of class&lt;dict&gt; of type&lt;ModuleEnrollment&gt;
        &#34;&#34;&#34;
        self.enrollments = await self.prisma.moduleenrollment.find_many()

        enrollments = []

        for i in range(len(self.enrollments)):
            enrollments.append(self.enrollments[i].dict())

        return enrollments

    async def _getFeedbacks(self):
        &#34;&#34;&#34;
        Gets all feedbacks from the database and returns them as a list of dictionaries.
        :return: class&lt;list&gt; of class&lt;dict&gt; of type&lt;ModuleFeedback&gt;
        &#34;&#34;&#34;
        self.feedbacks = await self.prisma.modulefeedback.find_many()

        feedbacks = []

        for i in range(len(self.feedbacks)):
            feedbacks.append(self.feedbacks[i].dict())

        return feedbacks

    async def _getPlans(self) -&gt; list[dict]:
        self.plans = await self.prisma.planofstudy.find_many()

        plans = []

        for i in range(len(self.plans)):
            plans.append(self.plans[i].dict())

        return plans

    async def _seedUserDB(self):
        &#34;&#34;&#34;
        Seeds the user model with dummy data as many times as described by the iterations&#39; member.
        :return: None
        &#34;&#34;&#34;
        self.logger.info(&#39;Seeding user model...&#39;)
        accounts = []

        for i in range(self.iterations):
            accounts.append({
                &#39;firstName&#39;: self.gen.name(),
                &#39;lastName&#39;: self.gen.name(),
                &#39;email&#39;: self.gen.email(),
                &#39;openID&#39;: str(self.gen.integer()),
            })

        users = await self.prisma.user.create_many(data=accounts)

        self.accounts = accounts
        self.logger.info(&#39;User model seeded successfully with %d documents!&#39; % users)

    async def _seedModuleDB(self):
        &#34;&#34;&#34;
        Seeds the module model with dummy data as many times as described by the iterations&#39; member.
        :return: None
        &#34;&#34;&#34;
        self.logger.info(&#39;Seeding module model...&#39;)
        modules = []

        template = {
            &#39;moduleName&#39;: {
                &#39;typemap&#39;: &#39;sentence&#39;,
                &#39;unique&#39;: True,
                &#39;tries&#39;: 100
            },
            &#39;moduleNumber&#39;: {
                &#39;typemap&#39;: &#39;integer&#39;,
                &#39;unique&#39;: True,
                &#39;tries&#39;: 100
            },
            &#39;description&#39;: &#39;paragraph&#39;,
            &#39;duration&#39;: &#39;small_int&#39;,
            &#39;intro&#39;: &#39;sentence&#39;,
            &#39;numSlides&#39;: &#39;small_int&#39;,
            &#39;keywords&#39;: {
                &#39;set&#39;: [&#39;engineering&#39;, &#39;mathematics&#39;, &#39;physics&#39;, &#39;chemistry&#39;, &#39;biology&#39;, &#39;computer science&#39;,
                        &#39;economics&#39;]
            }
        }

        self.gen.set_template(template)
        docs = self.gen.documents(self.iterations)

        module_res = await self.prisma.module.create_many(data=docs)

        self.modules = modules
        self.logger.info(&#39;Module model seeded successfully with %d documents!&#39; % module_res)

    def _is_float_(self, num: str):
        try:
            if float(num).is_integer():
                return False
            return True
        except ValueError:
            return False

    # function to create acronym
    def fxn(self, stng: str):
        # add first letter
        oupt = stng[0]
        # iterate over string
        for i in range(1, len(stng)):
            if stng[i - 1] == &#39; &#39;:
                # add letter next to space
                oupt += stng[i]
        # uppercase oupt
        oupt = oupt.upper()
        return oupt

    async def seedModuleFromFile(self, path: str):
        &#34;&#34;&#34;
        Seeds the module model with data from a csv file. The structure of the files must be as follows:
            - the first two rows should be ignored as they contain the column names and data types
            - column 1: module number - if it is an integer, we will need to create a unique prefix for it. if it is a float, the prefix will be the integer part of the number and the decimal number will be the module number
            - column 2: module name
            - column 3: module description
            - column 4: module objectives - this will be a list of strings separated by a semicolon
            - column 5: module keywords - this will be a list of strings separated by a semicolon
            - column 6: module hours - this will be an float number representing the number of hours the module will take to complete

        :return: Boolean
        &#34;&#34;&#34;
        self.logger.info(&#39;Seeding module model from file...&#39;)

        modules = list()

        with open(path, &#39;r&#39;) as csvFile:
            parsedFile = csv.reader(csvFile, delimiter=&#39;\t&#39;, quotechar=&#39;|&#39;)
            next(parsedFile)
            prefix = &#39;&#39;

            for row in parsedFile:
                document = dict()

                if float(row[0]).is_integer():
                    prefix = self.fxn(row[1])
                    document[&#39;number&#39;] = 0
                else:
                    dec = row[0].split(&#39;.&#39;)
                    document[&#39;number&#39;] = dec[1]

                document[&#39;name&#39;] = row[1]
                document[&#39;prefix&#39;] = prefix
                document[&#39;description&#39;] = row[2]
                document[&#39;objectives&#39;] = row[3].split(&#39;;&#39;)
                document[&#39;keywords&#39;] = row[4].split(&#39;;&#39;)

                if row[5] == &#39; &#39; or row[5] == &#39;&#39;:
                    document[&#39;hours&#39;] = np.random.uniform(0.25, 2)
                else:
                    document[&#39;hours&#39;] = float(row[5])

                modules.append(document)

        message = Template(&#39;Successfully parsed $number documents from file $name!&#39;)

        self.logger.info(message.substitute(number=len(modules), name=path.split(&#39;/&#39;)[-1]))

        # send each element in the array to the GraphQL API endpoint without using Prisma

        for module in modules:
            query = Template(&#34;&#34;&#34;
                mutation {
                    createModule(input: {
                        name: &#34;$name&#34;
                        number: $number
                        prefix: &#34;$prefix&#34;
                        description: &#34;$description&#34;
                        objectives: [$objectives]
                        keywords: [$keywords]
                        hours: $hours
                    }) {
                        id
                    }
                }
            &#34;&#34;&#34;)

            cleanedObjectives = &#34;&#34;

            for obj in module[&#39;objectives&#39;]:
                curr = obj.split(&#39;;&#39;)[0]
                if len(curr) == 0:
                    continue
                if curr[0] == &#39;&#34;&#39; and curr[-1] == &#39;&#34;&#39;:
                    cleanedObjectives += &#39;&#39; + obj.split(&#39;;&#39;)[0] + &#39;,&#39;
                elif curr[0] == &#39;&#34;&#39; and curr[-1] != &#39;&#34;&#39;:
                    cleanedObjectives += &#39;&#39; + obj.split(&#39;;&#39;)[0] + &#39;&#34;,&#39;
                else:
                    cleanedObjectives += &#39;&#34;&#39; + obj.split(&#39;;&#39;)[0] + &#39;&#34;,&#39;

            cleanedKeys = &#34;&#34;
            for key in module[&#39;keywords&#39;]:
                if len(key) == 0:
                    continue
                if key[0] == &#39;&#34;&#39; and key[-1] == &#39;&#34;&#39;:
                    cleanedKeys += &#39;&#39; + key + &#39;,&#39;
                elif key[0] == &#39;&#34;&#39; and key[-1] != &#39;&#34;&#39;:
                    cleanedKeys += &#39;&#39; + key + &#39;&#34;,&#39;
                else:
                    cleanedKeys += &#39;&#34;&#39; + key + &#39;&#34;,&#39;

            finalizedQuery = query.substitute(
                name=module[&#39;name&#39;],
                number=module[&#39;number&#39;],
                prefix=module[&#39;prefix&#39;],
                description=module[&#39;description&#39;],
                objectives=cleanedObjectives,
                keywords=cleanedKeys.strip(&#39;,&#39;),
                hours=module[&#39;hours&#39;]
            )

            # print(finalizedQuery)

            res: Response = post(&#34;http://localhost:4000/graphql&#34;, json={&#39;query&#39;: finalizedQuery})

            # print(res.text)

            if res.status_code != 200:
                self.logger.error(&#39;Failed to seed module model from file!&#39;)
                return False

        return True

    async def _seedPlanOfStudyDB(self):
        &#34;&#34;&#34;
        Seeds the plan of study model with dummy data for each account already present in the DB.
        :return:
        &#34;&#34;&#34;
        self.logger.info(&#39;Seeding plan of study model...&#39;)
        plans = []

        for account in self.accounts:
            plans.append({
                &#39;studentID&#39;: account[&#39;id&#39;],
            })

        plan_res = await self.prisma.planofstudy.create_many(data=plans)

        self.plans = plans
        self.logger.info(&#39;Plan of study model seeded successfully with %d documents!&#39; % plan_res)

    async def _seedEnrollmentDB(self):
        &#34;&#34;&#34;
        Enroll each account in each module with a random role. The number of documents that will be created is equal
        to the number of plan of studies multiplied by the number of modules.
        :return: None
        &#34;&#34;&#34;
        self.logger.info(&#39;Seeding enrollment model...&#39;)
        enrollments = []

        class EnrollmentRole(Enum):
            STUDENT = 1
            TEACHER = 2
            GRADER = 3

        for pos in self.plans:
            for module in self.modules:
                enrollments.append({
                    &#39;planID&#39;: pos[&#39;id&#39;],
                    &#39;moduleId&#39;: module[&#39;id&#39;],
                    &#39;role&#39;: np.random.choice(list(EnrollmentRole)).name
                })

        enrollment_res = await self.prisma.moduleenrollment.create_many(data=enrollments)

        self.enrollments = enrollments
        self.logger.info(&#39;Enrollment model seeded successfully with %d documents!&#39; % enrollment_res)

    async def _seedFeedbackDB(self):
        &#34;&#34;&#34;
        Seed the feedback model with dummy data for each enrollment. The number of documents that will be created is
        equal to the number of enrollments.
        :return: None
        &#34;&#34;&#34;
        self.logger.info(&#39;Seeding feedback model...&#39;)
        feedbacks = []

        # find the user&#39;s ID given a plan ID
        plans = await self._getPlans()

        for enrollment in self.enrollments:
            feedbacks.append({
                &#39;moduleId&#39;: enrollment[&#39;moduleId&#39;],
                &#39;rating&#39;: np.random.randint(1, 6),
                &#39;feedback&#39;: self.gen.sentence(),
                &#39;studentId&#39;: list(
                    map(lambda x: x[&#39;studentID&#39;], filter(lambda x: x[&#39;id&#39;] == enrollment[&#39;planID&#39;], plans))).pop()
            })

        feedback_res = await self.prisma.modulefeedback.create_many(data=feedbacks)
        self.feedbacks = feedbacks
        self.logger.info(&#39;Feedback model seeded successfully with %d documents!&#39; % feedback_res)

    async def seedAll(self):
        &#34;&#34;&#34;
        Calls all the seeding methods in the correct order. If the skip member is set to Skipper.all, then all seeding
        operations will be skipped. If the skip member is set to Skipper.&lt;modelName&gt;, then the &lt;modelName&gt; model seeding
        will be skipped.
        :return: None
        &#34;&#34;&#34;
        await self.connect()
        self.logger.info(&#39;Seeding operation started...&#39;)
        if Skipper.all in self.skip:
            self.logger.info(&#39;Skipping all model seeding...&#39;)
        else:
            if Skipper.user in self.skip:
                self.logger.info(&#39;Skipping user model seeding...&#39;)
                self.accounts = await self._getUserAccounts()
            else:
                await self._seedUserDB()

            if Skipper.module in self.skip:
                self.logger.info(&#39;Skipping module model seeding...&#39;)
                self.modules = await self._getModules()
            else:
                await self._seedModuleDB()

            if Skipper.plan in self.skip:
                self.logger.info(&#39;Skipping plan of study model seeding...&#39;)
                self.plans = await self._getPlans()
            else:
                await self._seedPlanOfStudyDB()

            if Skipper.enrollment in self.skip:
                self.logger.info(&#39;Skipping enrollment model seeding...&#39;)
                self.enrollments = await self._getEnrollments()
            else:
                await self._seedEnrollmentDB()

            if Skipper.feedback in self.skip:
                self.logger.info(&#39;Skipping feedback model seeding...&#39;)
                self.feedbacks = await self._getFeedbacks()
            else:
                await self._seedFeedbackDB()

            self.logger.info(&#39;All models seeded successfully!&#39;)
        await self.disconnect()

    async def cleanupAll(self):
        &#34;&#34;&#34;
        Calls all the cleanup methods in the correct order. If the cleanup member is set to Skipper.all, then all
        cleanup operations will be skipped. If the cleanup member is set to Skipper.&lt;modelName&gt;, then the &lt;modelName&gt;
        model cleanup will be skipped.
        :return:
        &#34;&#34;&#34;
        await self.connect()
        self.logger.info(&#39;Cleanup operation started...&#39;)

        if Skipper.all in self.cleanup:
            self.logger.info(&#39;Skipping all model cleanup...&#39;)
            return
        else:
            # Deleting all users
            if Skipper.user in self.cleanup:
                self.logger.info(&#39;Skipping user model cleanup...&#39;)
            else:
                await self._cleanupUserDB()

            # Deleting all plans of study
            if Skipper.plan in self.cleanup:
                self.logger.info(&#39;Skipping plan of study model cleanup...&#39;)
            else:
                await self._cleanupPlanOfStudyDB()

            # Deleting all enrollments
            if Skipper.enrollment in self.cleanup:
                self.logger.info(&#39;Skipping enrollment model cleanup...&#39;)
            else:
                await self._cleanupEnrollmentDB()

            # Deleting all modules
            if Skipper.module in self.cleanup:
                self.logger.info(&#39;Skipping module model cleanup...&#39;)
            else:
                await self._cleanupModuleDB()

            # Deleting all module feedback
            if Skipper.feedback in self.cleanup:
                self.logger.info(&#39;Skipping feedback model cleanup...&#39;)
            else:
                await self._cleanupFeedbackDB()

            self.logger.info(&#39;All models cleaned up successfully!&#39;)
        await self.disconnect()

    async def _cleanupUserDB(self):
        count = await self.prisma.user.delete_many()
        self.logger.info(&#39;User model cleaned up successfully! (%d documents deleted)&#39; % count)

    async def _cleanupModuleDB(self):
        count = await self.prisma.module.delete_many()
        self.logger.info(&#39;Module model cleaned up successfully! (%d documents deleted)&#39; % count)

    async def _cleanupFeedbackDB(self):
        count = await self.prisma.modulefeedback.delete_many()
        self.logger.info(&#39;Feedback model cleaned up successfully! (%d documents deleted)&#39; % count)

    async def _cleanupPlanOfStudyDB(self):
        count = await self.prisma.planofstudy.delete_many()
        self.logger.info(&#39;Plan of study model cleaned up successfully! (%d documents deleted)&#39; % count)

    async def _cleanupEnrollmentDB(self):
        count = await self.prisma.moduleenrollment.delete_many()
        self.logger.info(&#39;Enrollment model cleaned up successfully! (%d documents deleted)&#39; % count)


async def main():
    seeder = Seeder(
        skip=[Skipper.all],
        cleanup=[Skipper.all],
    )
    modules = [
        # &#39;../input/ENMA603_1.txt&#39;,
        # &#39;../input/ENMA603_2.txt&#39;,
        # &#39;../input/ENMA603_3.txt&#39;,
        # &#39;../input/ENMA603_4.txt&#39;,
        # &#39;../input/ENMA603_5.txt&#39;,
        # &#39;../input/ENMA603_6.txt&#39;,
        # &#39;../input/ENMA603_7.txt&#39;,
        # &#39;../input/ENMA603_8.txt&#39;,
        # &#39;../input/ENMA603_9.txt&#39;,
        # &#39;../input/ENMA603_10.txt&#39;,
        # &#39;../input/ENMA603_11.txt&#39;,
        # &#39;../input/ENMA603_12.txt&#39;,
        # &#39;../input/ENMA603_13.txt&#39;,
        # &#39;../input/ENMA603_14.txt&#39;,
    ]

    for module in modules:
        await seeder.seedModuleFromFile(path=module)


if __name__ == &#39;__main__&#39;:
    asyncio.run(main())</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="emse-mms.utils.seed.getModuleFeedback"><code class="name flex">
<span>def <span class="ident">getModuleFeedback</span></span>(<span>)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def getModuleFeedback():
    mods = post(&#39;http://%s/graphql&#39; % os.environ.get(&#34;API_URL&#34;, &#34;client:4000&#34;), {}, {
        &#39;query&#39;: &#34;&#34;&#34;query{
          module(input:{}){
            id
            moduleName
            moduleNumber
            feedback{
              rating
              feedback
            }
            members{
              id
            }
          }
        }&#34;&#34;&#34;
    })
    return mods.json()[&#39;data&#39;]</code></pre>
</details>
</dd>
<dt id="emse-mms.utils.seed.main"><code class="name flex">
<span>async def <span class="ident">main</span></span>(<span>)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def main():
    seeder = Seeder(
        skip=[Skipper.all],
        cleanup=[Skipper.all],
    )
    modules = [
        # &#39;../input/ENMA603_1.txt&#39;,
        # &#39;../input/ENMA603_2.txt&#39;,
        # &#39;../input/ENMA603_3.txt&#39;,
        # &#39;../input/ENMA603_4.txt&#39;,
        # &#39;../input/ENMA603_5.txt&#39;,
        # &#39;../input/ENMA603_6.txt&#39;,
        # &#39;../input/ENMA603_7.txt&#39;,
        # &#39;../input/ENMA603_8.txt&#39;,
        # &#39;../input/ENMA603_9.txt&#39;,
        # &#39;../input/ENMA603_10.txt&#39;,
        # &#39;../input/ENMA603_11.txt&#39;,
        # &#39;../input/ENMA603_12.txt&#39;,
        # &#39;../input/ENMA603_13.txt&#39;,
        # &#39;../input/ENMA603_14.txt&#39;,
    ]

    for module in modules:
        await seeder.seedModuleFromFile(path=module)</code></pre>
</details>
</dd>
</dl>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="emse-mms.utils.seed.Seeder"><code class="flex name class">
<span>class <span class="ident">Seeder</span></span>
<span>(</span><span>skip: [<enum '<a title="emse-mms.utils.seed.Skipper" href="#emse-mms.utils.seed.Skipper">Skipper</a>'>] = None, cleanup: [<enum '<a title="emse-mms.utils.seed.Skipper" href="#emse-mms.utils.seed.Skipper">Skipper</a>'>] = None, iterations: int = 25, target: Optional[str] = None)</span>
</code></dt>
<dd>
<div class="desc"><p>Seeder class for seeding the database with dummy data. Makes use of the prisma python client to connection to the
database and the essential_generators library to create document templates.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Seeder:
    &#34;&#34;&#34;
    Seeder class for seeding the database with dummy data. Makes use of the prisma python client to connection to the
    database and the essential_generators library to create document templates.
    &#34;&#34;&#34;

    def __init__(self, skip: [Skipper] = None, cleanup: [Skipper] = None, iterations: int = 25,
                 target: Union[str, None] = None):
        self.gen = DocumentGenerator()
        self.gen.init_word_cache(5000)
        self.gen.init_sentence_cache(5000)
        self.prisma = Prisma()
        self.iterations = iterations
        self.accounts = []
        self.modules = []
        self.enrollments = []
        self.feedbacks = []
        self.plans = []
        self.skip = skip
        self.cleanup = cleanup
        self.target = target
        self.logger = logging.getLogger(&#39;__seed__&#39;)
        logging.basicConfig(format=&#39;%(levelname)s:%(message)s&#39;, level=logging.INFO)

    async def connect(self):
        &#34;&#34;&#34;
        Connects to the database using prisma client.
        &#34;&#34;&#34;
        await self.prisma.connect()

    async def disconnect(self):
        &#34;&#34;&#34;
        Disconnects from the database using prisma client.
        &#34;&#34;&#34;
        await self.prisma.disconnect()

    async def createTargetUser(self):
        &#34;&#34;&#34;
        Creates a target user for testing purposes.
        &#34;&#34;&#34;
        account = await self.prisma.user.create(data={
            &#39;firstName&#39;: &#39;Test User&#39;,
            &#39;lastName&#39;: &#39;Test User&#39;,
            &#39;email&#39;: &#39;&#39;,
            &#39;openID&#39;: &#39;&#39;
        })

        self.logger.info(&#39;Created target user: %s&#39; % account.id)
        return account.id

    async def _getUserAccounts(self):
        &#34;&#34;&#34;
        Gets all user accounts from the database and returns them as a list of dictionaries.
        :return: class&lt;list&gt; of class&lt;dict&gt; of type&lt;User&gt;
        &#34;&#34;&#34;
        accounts = await self.prisma.user.find_many()

        acc = []

        for i in range(len(accounts)):
            acc.append(accounts[i].dict())

        return acc

    async def _getModules(self):
        &#34;&#34;&#34;
        Gets all modules from the database and returns them as a list of dictionaries.
        :return: class&lt;list&gt; of class&lt;dict&gt; of type&lt;Module&gt;
        &#34;&#34;&#34;
        self.modules = await self.prisma.module.find_many()

        mods = []

        for i in range(len(self.modules)):
            mods.append(self.modules[i].dict())

        return mods

    async def _getEnrollments(self):
        &#34;&#34;&#34;
        Gets all enrollments from the database and returns them as a list of dictionaries.
        :return: class&lt;list&gt; of class&lt;dict&gt; of type&lt;ModuleEnrollment&gt;
        &#34;&#34;&#34;
        self.enrollments = await self.prisma.moduleenrollment.find_many()

        enrollments = []

        for i in range(len(self.enrollments)):
            enrollments.append(self.enrollments[i].dict())

        return enrollments

    async def _getFeedbacks(self):
        &#34;&#34;&#34;
        Gets all feedbacks from the database and returns them as a list of dictionaries.
        :return: class&lt;list&gt; of class&lt;dict&gt; of type&lt;ModuleFeedback&gt;
        &#34;&#34;&#34;
        self.feedbacks = await self.prisma.modulefeedback.find_many()

        feedbacks = []

        for i in range(len(self.feedbacks)):
            feedbacks.append(self.feedbacks[i].dict())

        return feedbacks

    async def _getPlans(self) -&gt; list[dict]:
        self.plans = await self.prisma.planofstudy.find_many()

        plans = []

        for i in range(len(self.plans)):
            plans.append(self.plans[i].dict())

        return plans

    async def _seedUserDB(self):
        &#34;&#34;&#34;
        Seeds the user model with dummy data as many times as described by the iterations&#39; member.
        :return: None
        &#34;&#34;&#34;
        self.logger.info(&#39;Seeding user model...&#39;)
        accounts = []

        for i in range(self.iterations):
            accounts.append({
                &#39;firstName&#39;: self.gen.name(),
                &#39;lastName&#39;: self.gen.name(),
                &#39;email&#39;: self.gen.email(),
                &#39;openID&#39;: str(self.gen.integer()),
            })

        users = await self.prisma.user.create_many(data=accounts)

        self.accounts = accounts
        self.logger.info(&#39;User model seeded successfully with %d documents!&#39; % users)

    async def _seedModuleDB(self):
        &#34;&#34;&#34;
        Seeds the module model with dummy data as many times as described by the iterations&#39; member.
        :return: None
        &#34;&#34;&#34;
        self.logger.info(&#39;Seeding module model...&#39;)
        modules = []

        template = {
            &#39;moduleName&#39;: {
                &#39;typemap&#39;: &#39;sentence&#39;,
                &#39;unique&#39;: True,
                &#39;tries&#39;: 100
            },
            &#39;moduleNumber&#39;: {
                &#39;typemap&#39;: &#39;integer&#39;,
                &#39;unique&#39;: True,
                &#39;tries&#39;: 100
            },
            &#39;description&#39;: &#39;paragraph&#39;,
            &#39;duration&#39;: &#39;small_int&#39;,
            &#39;intro&#39;: &#39;sentence&#39;,
            &#39;numSlides&#39;: &#39;small_int&#39;,
            &#39;keywords&#39;: {
                &#39;set&#39;: [&#39;engineering&#39;, &#39;mathematics&#39;, &#39;physics&#39;, &#39;chemistry&#39;, &#39;biology&#39;, &#39;computer science&#39;,
                        &#39;economics&#39;]
            }
        }

        self.gen.set_template(template)
        docs = self.gen.documents(self.iterations)

        module_res = await self.prisma.module.create_many(data=docs)

        self.modules = modules
        self.logger.info(&#39;Module model seeded successfully with %d documents!&#39; % module_res)

    def _is_float_(self, num: str):
        try:
            if float(num).is_integer():
                return False
            return True
        except ValueError:
            return False

    # function to create acronym
    def fxn(self, stng: str):
        # add first letter
        oupt = stng[0]
        # iterate over string
        for i in range(1, len(stng)):
            if stng[i - 1] == &#39; &#39;:
                # add letter next to space
                oupt += stng[i]
        # uppercase oupt
        oupt = oupt.upper()
        return oupt

    async def seedModuleFromFile(self, path: str):
        &#34;&#34;&#34;
        Seeds the module model with data from a csv file. The structure of the files must be as follows:
            - the first two rows should be ignored as they contain the column names and data types
            - column 1: module number - if it is an integer, we will need to create a unique prefix for it. if it is a float, the prefix will be the integer part of the number and the decimal number will be the module number
            - column 2: module name
            - column 3: module description
            - column 4: module objectives - this will be a list of strings separated by a semicolon
            - column 5: module keywords - this will be a list of strings separated by a semicolon
            - column 6: module hours - this will be an float number representing the number of hours the module will take to complete

        :return: Boolean
        &#34;&#34;&#34;
        self.logger.info(&#39;Seeding module model from file...&#39;)

        modules = list()

        with open(path, &#39;r&#39;) as csvFile:
            parsedFile = csv.reader(csvFile, delimiter=&#39;\t&#39;, quotechar=&#39;|&#39;)
            next(parsedFile)
            prefix = &#39;&#39;

            for row in parsedFile:
                document = dict()

                if float(row[0]).is_integer():
                    prefix = self.fxn(row[1])
                    document[&#39;number&#39;] = 0
                else:
                    dec = row[0].split(&#39;.&#39;)
                    document[&#39;number&#39;] = dec[1]

                document[&#39;name&#39;] = row[1]
                document[&#39;prefix&#39;] = prefix
                document[&#39;description&#39;] = row[2]
                document[&#39;objectives&#39;] = row[3].split(&#39;;&#39;)
                document[&#39;keywords&#39;] = row[4].split(&#39;;&#39;)

                if row[5] == &#39; &#39; or row[5] == &#39;&#39;:
                    document[&#39;hours&#39;] = np.random.uniform(0.25, 2)
                else:
                    document[&#39;hours&#39;] = float(row[5])

                modules.append(document)

        message = Template(&#39;Successfully parsed $number documents from file $name!&#39;)

        self.logger.info(message.substitute(number=len(modules), name=path.split(&#39;/&#39;)[-1]))

        # send each element in the array to the GraphQL API endpoint without using Prisma

        for module in modules:
            query = Template(&#34;&#34;&#34;
                mutation {
                    createModule(input: {
                        name: &#34;$name&#34;
                        number: $number
                        prefix: &#34;$prefix&#34;
                        description: &#34;$description&#34;
                        objectives: [$objectives]
                        keywords: [$keywords]
                        hours: $hours
                    }) {
                        id
                    }
                }
            &#34;&#34;&#34;)

            cleanedObjectives = &#34;&#34;

            for obj in module[&#39;objectives&#39;]:
                curr = obj.split(&#39;;&#39;)[0]
                if len(curr) == 0:
                    continue
                if curr[0] == &#39;&#34;&#39; and curr[-1] == &#39;&#34;&#39;:
                    cleanedObjectives += &#39;&#39; + obj.split(&#39;;&#39;)[0] + &#39;,&#39;
                elif curr[0] == &#39;&#34;&#39; and curr[-1] != &#39;&#34;&#39;:
                    cleanedObjectives += &#39;&#39; + obj.split(&#39;;&#39;)[0] + &#39;&#34;,&#39;
                else:
                    cleanedObjectives += &#39;&#34;&#39; + obj.split(&#39;;&#39;)[0] + &#39;&#34;,&#39;

            cleanedKeys = &#34;&#34;
            for key in module[&#39;keywords&#39;]:
                if len(key) == 0:
                    continue
                if key[0] == &#39;&#34;&#39; and key[-1] == &#39;&#34;&#39;:
                    cleanedKeys += &#39;&#39; + key + &#39;,&#39;
                elif key[0] == &#39;&#34;&#39; and key[-1] != &#39;&#34;&#39;:
                    cleanedKeys += &#39;&#39; + key + &#39;&#34;,&#39;
                else:
                    cleanedKeys += &#39;&#34;&#39; + key + &#39;&#34;,&#39;

            finalizedQuery = query.substitute(
                name=module[&#39;name&#39;],
                number=module[&#39;number&#39;],
                prefix=module[&#39;prefix&#39;],
                description=module[&#39;description&#39;],
                objectives=cleanedObjectives,
                keywords=cleanedKeys.strip(&#39;,&#39;),
                hours=module[&#39;hours&#39;]
            )

            # print(finalizedQuery)

            res: Response = post(&#34;http://localhost:4000/graphql&#34;, json={&#39;query&#39;: finalizedQuery})

            # print(res.text)

            if res.status_code != 200:
                self.logger.error(&#39;Failed to seed module model from file!&#39;)
                return False

        return True

    async def _seedPlanOfStudyDB(self):
        &#34;&#34;&#34;
        Seeds the plan of study model with dummy data for each account already present in the DB.
        :return:
        &#34;&#34;&#34;
        self.logger.info(&#39;Seeding plan of study model...&#39;)
        plans = []

        for account in self.accounts:
            plans.append({
                &#39;studentID&#39;: account[&#39;id&#39;],
            })

        plan_res = await self.prisma.planofstudy.create_many(data=plans)

        self.plans = plans
        self.logger.info(&#39;Plan of study model seeded successfully with %d documents!&#39; % plan_res)

    async def _seedEnrollmentDB(self):
        &#34;&#34;&#34;
        Enroll each account in each module with a random role. The number of documents that will be created is equal
        to the number of plan of studies multiplied by the number of modules.
        :return: None
        &#34;&#34;&#34;
        self.logger.info(&#39;Seeding enrollment model...&#39;)
        enrollments = []

        class EnrollmentRole(Enum):
            STUDENT = 1
            TEACHER = 2
            GRADER = 3

        for pos in self.plans:
            for module in self.modules:
                enrollments.append({
                    &#39;planID&#39;: pos[&#39;id&#39;],
                    &#39;moduleId&#39;: module[&#39;id&#39;],
                    &#39;role&#39;: np.random.choice(list(EnrollmentRole)).name
                })

        enrollment_res = await self.prisma.moduleenrollment.create_many(data=enrollments)

        self.enrollments = enrollments
        self.logger.info(&#39;Enrollment model seeded successfully with %d documents!&#39; % enrollment_res)

    async def _seedFeedbackDB(self):
        &#34;&#34;&#34;
        Seed the feedback model with dummy data for each enrollment. The number of documents that will be created is
        equal to the number of enrollments.
        :return: None
        &#34;&#34;&#34;
        self.logger.info(&#39;Seeding feedback model...&#39;)
        feedbacks = []

        # find the user&#39;s ID given a plan ID
        plans = await self._getPlans()

        for enrollment in self.enrollments:
            feedbacks.append({
                &#39;moduleId&#39;: enrollment[&#39;moduleId&#39;],
                &#39;rating&#39;: np.random.randint(1, 6),
                &#39;feedback&#39;: self.gen.sentence(),
                &#39;studentId&#39;: list(
                    map(lambda x: x[&#39;studentID&#39;], filter(lambda x: x[&#39;id&#39;] == enrollment[&#39;planID&#39;], plans))).pop()
            })

        feedback_res = await self.prisma.modulefeedback.create_many(data=feedbacks)
        self.feedbacks = feedbacks
        self.logger.info(&#39;Feedback model seeded successfully with %d documents!&#39; % feedback_res)

    async def seedAll(self):
        &#34;&#34;&#34;
        Calls all the seeding methods in the correct order. If the skip member is set to Skipper.all, then all seeding
        operations will be skipped. If the skip member is set to Skipper.&lt;modelName&gt;, then the &lt;modelName&gt; model seeding
        will be skipped.
        :return: None
        &#34;&#34;&#34;
        await self.connect()
        self.logger.info(&#39;Seeding operation started...&#39;)
        if Skipper.all in self.skip:
            self.logger.info(&#39;Skipping all model seeding...&#39;)
        else:
            if Skipper.user in self.skip:
                self.logger.info(&#39;Skipping user model seeding...&#39;)
                self.accounts = await self._getUserAccounts()
            else:
                await self._seedUserDB()

            if Skipper.module in self.skip:
                self.logger.info(&#39;Skipping module model seeding...&#39;)
                self.modules = await self._getModules()
            else:
                await self._seedModuleDB()

            if Skipper.plan in self.skip:
                self.logger.info(&#39;Skipping plan of study model seeding...&#39;)
                self.plans = await self._getPlans()
            else:
                await self._seedPlanOfStudyDB()

            if Skipper.enrollment in self.skip:
                self.logger.info(&#39;Skipping enrollment model seeding...&#39;)
                self.enrollments = await self._getEnrollments()
            else:
                await self._seedEnrollmentDB()

            if Skipper.feedback in self.skip:
                self.logger.info(&#39;Skipping feedback model seeding...&#39;)
                self.feedbacks = await self._getFeedbacks()
            else:
                await self._seedFeedbackDB()

            self.logger.info(&#39;All models seeded successfully!&#39;)
        await self.disconnect()

    async def cleanupAll(self):
        &#34;&#34;&#34;
        Calls all the cleanup methods in the correct order. If the cleanup member is set to Skipper.all, then all
        cleanup operations will be skipped. If the cleanup member is set to Skipper.&lt;modelName&gt;, then the &lt;modelName&gt;
        model cleanup will be skipped.
        :return:
        &#34;&#34;&#34;
        await self.connect()
        self.logger.info(&#39;Cleanup operation started...&#39;)

        if Skipper.all in self.cleanup:
            self.logger.info(&#39;Skipping all model cleanup...&#39;)
            return
        else:
            # Deleting all users
            if Skipper.user in self.cleanup:
                self.logger.info(&#39;Skipping user model cleanup...&#39;)
            else:
                await self._cleanupUserDB()

            # Deleting all plans of study
            if Skipper.plan in self.cleanup:
                self.logger.info(&#39;Skipping plan of study model cleanup...&#39;)
            else:
                await self._cleanupPlanOfStudyDB()

            # Deleting all enrollments
            if Skipper.enrollment in self.cleanup:
                self.logger.info(&#39;Skipping enrollment model cleanup...&#39;)
            else:
                await self._cleanupEnrollmentDB()

            # Deleting all modules
            if Skipper.module in self.cleanup:
                self.logger.info(&#39;Skipping module model cleanup...&#39;)
            else:
                await self._cleanupModuleDB()

            # Deleting all module feedback
            if Skipper.feedback in self.cleanup:
                self.logger.info(&#39;Skipping feedback model cleanup...&#39;)
            else:
                await self._cleanupFeedbackDB()

            self.logger.info(&#39;All models cleaned up successfully!&#39;)
        await self.disconnect()

    async def _cleanupUserDB(self):
        count = await self.prisma.user.delete_many()
        self.logger.info(&#39;User model cleaned up successfully! (%d documents deleted)&#39; % count)

    async def _cleanupModuleDB(self):
        count = await self.prisma.module.delete_many()
        self.logger.info(&#39;Module model cleaned up successfully! (%d documents deleted)&#39; % count)

    async def _cleanupFeedbackDB(self):
        count = await self.prisma.modulefeedback.delete_many()
        self.logger.info(&#39;Feedback model cleaned up successfully! (%d documents deleted)&#39; % count)

    async def _cleanupPlanOfStudyDB(self):
        count = await self.prisma.planofstudy.delete_many()
        self.logger.info(&#39;Plan of study model cleaned up successfully! (%d documents deleted)&#39; % count)

    async def _cleanupEnrollmentDB(self):
        count = await self.prisma.moduleenrollment.delete_many()
        self.logger.info(&#39;Enrollment model cleaned up successfully! (%d documents deleted)&#39; % count)</code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="emse-mms.utils.seed.Seeder.cleanupAll"><code class="name flex">
<span>async def <span class="ident">cleanupAll</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Calls all the cleanup methods in the correct order. If the cleanup member is set to Skipper.all, then all
cleanup operations will be skipped. If the cleanup member is set to Skipper.<modelName>, then the <modelName>
model cleanup will be skipped.
:return:</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def cleanupAll(self):
    &#34;&#34;&#34;
    Calls all the cleanup methods in the correct order. If the cleanup member is set to Skipper.all, then all
    cleanup operations will be skipped. If the cleanup member is set to Skipper.&lt;modelName&gt;, then the &lt;modelName&gt;
    model cleanup will be skipped.
    :return:
    &#34;&#34;&#34;
    await self.connect()
    self.logger.info(&#39;Cleanup operation started...&#39;)

    if Skipper.all in self.cleanup:
        self.logger.info(&#39;Skipping all model cleanup...&#39;)
        return
    else:
        # Deleting all users
        if Skipper.user in self.cleanup:
            self.logger.info(&#39;Skipping user model cleanup...&#39;)
        else:
            await self._cleanupUserDB()

        # Deleting all plans of study
        if Skipper.plan in self.cleanup:
            self.logger.info(&#39;Skipping plan of study model cleanup...&#39;)
        else:
            await self._cleanupPlanOfStudyDB()

        # Deleting all enrollments
        if Skipper.enrollment in self.cleanup:
            self.logger.info(&#39;Skipping enrollment model cleanup...&#39;)
        else:
            await self._cleanupEnrollmentDB()

        # Deleting all modules
        if Skipper.module in self.cleanup:
            self.logger.info(&#39;Skipping module model cleanup...&#39;)
        else:
            await self._cleanupModuleDB()

        # Deleting all module feedback
        if Skipper.feedback in self.cleanup:
            self.logger.info(&#39;Skipping feedback model cleanup...&#39;)
        else:
            await self._cleanupFeedbackDB()

        self.logger.info(&#39;All models cleaned up successfully!&#39;)
    await self.disconnect()</code></pre>
</details>
</dd>
<dt id="emse-mms.utils.seed.Seeder.connect"><code class="name flex">
<span>async def <span class="ident">connect</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Connects to the database using prisma client.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def connect(self):
    &#34;&#34;&#34;
    Connects to the database using prisma client.
    &#34;&#34;&#34;
    await self.prisma.connect()</code></pre>
</details>
</dd>
<dt id="emse-mms.utils.seed.Seeder.createTargetUser"><code class="name flex">
<span>async def <span class="ident">createTargetUser</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Creates a target user for testing purposes.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def createTargetUser(self):
    &#34;&#34;&#34;
    Creates a target user for testing purposes.
    &#34;&#34;&#34;
    account = await self.prisma.user.create(data={
        &#39;firstName&#39;: &#39;Test User&#39;,
        &#39;lastName&#39;: &#39;Test User&#39;,
        &#39;email&#39;: &#39;&#39;,
        &#39;openID&#39;: &#39;&#39;
    })

    self.logger.info(&#39;Created target user: %s&#39; % account.id)
    return account.id</code></pre>
</details>
</dd>
<dt id="emse-mms.utils.seed.Seeder.disconnect"><code class="name flex">
<span>async def <span class="ident">disconnect</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Disconnects from the database using prisma client.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def disconnect(self):
    &#34;&#34;&#34;
    Disconnects from the database using prisma client.
    &#34;&#34;&#34;
    await self.prisma.disconnect()</code></pre>
</details>
</dd>
<dt id="emse-mms.utils.seed.Seeder.fxn"><code class="name flex">
<span>def <span class="ident">fxn</span></span>(<span>self, stng: str)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def fxn(self, stng: str):
    # add first letter
    oupt = stng[0]
    # iterate over string
    for i in range(1, len(stng)):
        if stng[i - 1] == &#39; &#39;:
            # add letter next to space
            oupt += stng[i]
    # uppercase oupt
    oupt = oupt.upper()
    return oupt</code></pre>
</details>
</dd>
<dt id="emse-mms.utils.seed.Seeder.seedAll"><code class="name flex">
<span>async def <span class="ident">seedAll</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Calls all the seeding methods in the correct order. If the skip member is set to Skipper.all, then all seeding
operations will be skipped. If the skip member is set to Skipper.<modelName>, then the <modelName> model seeding
will be skipped.
:return: None</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def seedAll(self):
    &#34;&#34;&#34;
    Calls all the seeding methods in the correct order. If the skip member is set to Skipper.all, then all seeding
    operations will be skipped. If the skip member is set to Skipper.&lt;modelName&gt;, then the &lt;modelName&gt; model seeding
    will be skipped.
    :return: None
    &#34;&#34;&#34;
    await self.connect()
    self.logger.info(&#39;Seeding operation started...&#39;)
    if Skipper.all in self.skip:
        self.logger.info(&#39;Skipping all model seeding...&#39;)
    else:
        if Skipper.user in self.skip:
            self.logger.info(&#39;Skipping user model seeding...&#39;)
            self.accounts = await self._getUserAccounts()
        else:
            await self._seedUserDB()

        if Skipper.module in self.skip:
            self.logger.info(&#39;Skipping module model seeding...&#39;)
            self.modules = await self._getModules()
        else:
            await self._seedModuleDB()

        if Skipper.plan in self.skip:
            self.logger.info(&#39;Skipping plan of study model seeding...&#39;)
            self.plans = await self._getPlans()
        else:
            await self._seedPlanOfStudyDB()

        if Skipper.enrollment in self.skip:
            self.logger.info(&#39;Skipping enrollment model seeding...&#39;)
            self.enrollments = await self._getEnrollments()
        else:
            await self._seedEnrollmentDB()

        if Skipper.feedback in self.skip:
            self.logger.info(&#39;Skipping feedback model seeding...&#39;)
            self.feedbacks = await self._getFeedbacks()
        else:
            await self._seedFeedbackDB()

        self.logger.info(&#39;All models seeded successfully!&#39;)
    await self.disconnect()</code></pre>
</details>
</dd>
<dt id="emse-mms.utils.seed.Seeder.seedModuleFromFile"><code class="name flex">
<span>async def <span class="ident">seedModuleFromFile</span></span>(<span>self, path: str)</span>
</code></dt>
<dd>
<div class="desc"><p>Seeds the module model with data from a csv file. The structure of the files must be as follows:
- the first two rows should be ignored as they contain the column names and data types
- column 1: module number - if it is an integer, we will need to create a unique prefix for it. if it is a float, the prefix will be the integer part of the number and the decimal number will be the module number
- column 2: module name
- column 3: module description
- column 4: module objectives - this will be a list of strings separated by a semicolon
- column 5: module keywords - this will be a list of strings separated by a semicolon
- column 6: module hours - this will be an float number representing the number of hours the module will take to complete</p>
<p>:return: Boolean</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def seedModuleFromFile(self, path: str):
    &#34;&#34;&#34;
    Seeds the module model with data from a csv file. The structure of the files must be as follows:
        - the first two rows should be ignored as they contain the column names and data types
        - column 1: module number - if it is an integer, we will need to create a unique prefix for it. if it is a float, the prefix will be the integer part of the number and the decimal number will be the module number
        - column 2: module name
        - column 3: module description
        - column 4: module objectives - this will be a list of strings separated by a semicolon
        - column 5: module keywords - this will be a list of strings separated by a semicolon
        - column 6: module hours - this will be an float number representing the number of hours the module will take to complete

    :return: Boolean
    &#34;&#34;&#34;
    self.logger.info(&#39;Seeding module model from file...&#39;)

    modules = list()

    with open(path, &#39;r&#39;) as csvFile:
        parsedFile = csv.reader(csvFile, delimiter=&#39;\t&#39;, quotechar=&#39;|&#39;)
        next(parsedFile)
        prefix = &#39;&#39;

        for row in parsedFile:
            document = dict()

            if float(row[0]).is_integer():
                prefix = self.fxn(row[1])
                document[&#39;number&#39;] = 0
            else:
                dec = row[0].split(&#39;.&#39;)
                document[&#39;number&#39;] = dec[1]

            document[&#39;name&#39;] = row[1]
            document[&#39;prefix&#39;] = prefix
            document[&#39;description&#39;] = row[2]
            document[&#39;objectives&#39;] = row[3].split(&#39;;&#39;)
            document[&#39;keywords&#39;] = row[4].split(&#39;;&#39;)

            if row[5] == &#39; &#39; or row[5] == &#39;&#39;:
                document[&#39;hours&#39;] = np.random.uniform(0.25, 2)
            else:
                document[&#39;hours&#39;] = float(row[5])

            modules.append(document)

    message = Template(&#39;Successfully parsed $number documents from file $name!&#39;)

    self.logger.info(message.substitute(number=len(modules), name=path.split(&#39;/&#39;)[-1]))

    # send each element in the array to the GraphQL API endpoint without using Prisma

    for module in modules:
        query = Template(&#34;&#34;&#34;
            mutation {
                createModule(input: {
                    name: &#34;$name&#34;
                    number: $number
                    prefix: &#34;$prefix&#34;
                    description: &#34;$description&#34;
                    objectives: [$objectives]
                    keywords: [$keywords]
                    hours: $hours
                }) {
                    id
                }
            }
        &#34;&#34;&#34;)

        cleanedObjectives = &#34;&#34;

        for obj in module[&#39;objectives&#39;]:
            curr = obj.split(&#39;;&#39;)[0]
            if len(curr) == 0:
                continue
            if curr[0] == &#39;&#34;&#39; and curr[-1] == &#39;&#34;&#39;:
                cleanedObjectives += &#39;&#39; + obj.split(&#39;;&#39;)[0] + &#39;,&#39;
            elif curr[0] == &#39;&#34;&#39; and curr[-1] != &#39;&#34;&#39;:
                cleanedObjectives += &#39;&#39; + obj.split(&#39;;&#39;)[0] + &#39;&#34;,&#39;
            else:
                cleanedObjectives += &#39;&#34;&#39; + obj.split(&#39;;&#39;)[0] + &#39;&#34;,&#39;

        cleanedKeys = &#34;&#34;
        for key in module[&#39;keywords&#39;]:
            if len(key) == 0:
                continue
            if key[0] == &#39;&#34;&#39; and key[-1] == &#39;&#34;&#39;:
                cleanedKeys += &#39;&#39; + key + &#39;,&#39;
            elif key[0] == &#39;&#34;&#39; and key[-1] != &#39;&#34;&#39;:
                cleanedKeys += &#39;&#39; + key + &#39;&#34;,&#39;
            else:
                cleanedKeys += &#39;&#34;&#39; + key + &#39;&#34;,&#39;

        finalizedQuery = query.substitute(
            name=module[&#39;name&#39;],
            number=module[&#39;number&#39;],
            prefix=module[&#39;prefix&#39;],
            description=module[&#39;description&#39;],
            objectives=cleanedObjectives,
            keywords=cleanedKeys.strip(&#39;,&#39;),
            hours=module[&#39;hours&#39;]
        )

        # print(finalizedQuery)

        res: Response = post(&#34;http://localhost:4000/graphql&#34;, json={&#39;query&#39;: finalizedQuery})

        # print(res.text)

        if res.status_code != 200:
            self.logger.error(&#39;Failed to seed module model from file!&#39;)
            return False

    return True</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="emse-mms.utils.seed.Skipper"><code class="flex name class">
<span>class <span class="ident">Skipper</span></span>
<span>(</span><span>value, names=None, *, module=None, qualname=None, type=None, start=1)</span>
</code></dt>
<dd>
<div class="desc"><p>An enumeration.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Skipper(Enum):
    user = 1
    module = 2
    feedback = 3
    plan = 4
    enrollment = 5
    all = 6</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>enum.Enum</li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="emse-mms.utils.seed.Skipper.all"><code class="name">var <span class="ident">all</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="emse-mms.utils.seed.Skipper.enrollment"><code class="name">var <span class="ident">enrollment</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="emse-mms.utils.seed.Skipper.feedback"><code class="name">var <span class="ident">feedback</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="emse-mms.utils.seed.Skipper.module"><code class="name">var <span class="ident">module</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="emse-mms.utils.seed.Skipper.plan"><code class="name">var <span class="ident">plan</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="emse-mms.utils.seed.Skipper.user"><code class="name">var <span class="ident">user</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="emse-mms.utils" href="index.html">emse-mms.utils</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="emse-mms.utils.seed.getModuleFeedback" href="#emse-mms.utils.seed.getModuleFeedback">getModuleFeedback</a></code></li>
<li><code><a title="emse-mms.utils.seed.main" href="#emse-mms.utils.seed.main">main</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="emse-mms.utils.seed.Seeder" href="#emse-mms.utils.seed.Seeder">Seeder</a></code></h4>
<ul class="two-column">
<li><code><a title="emse-mms.utils.seed.Seeder.cleanupAll" href="#emse-mms.utils.seed.Seeder.cleanupAll">cleanupAll</a></code></li>
<li><code><a title="emse-mms.utils.seed.Seeder.connect" href="#emse-mms.utils.seed.Seeder.connect">connect</a></code></li>
<li><code><a title="emse-mms.utils.seed.Seeder.createTargetUser" href="#emse-mms.utils.seed.Seeder.createTargetUser">createTargetUser</a></code></li>
<li><code><a title="emse-mms.utils.seed.Seeder.disconnect" href="#emse-mms.utils.seed.Seeder.disconnect">disconnect</a></code></li>
<li><code><a title="emse-mms.utils.seed.Seeder.fxn" href="#emse-mms.utils.seed.Seeder.fxn">fxn</a></code></li>
<li><code><a title="emse-mms.utils.seed.Seeder.seedAll" href="#emse-mms.utils.seed.Seeder.seedAll">seedAll</a></code></li>
<li><code><a title="emse-mms.utils.seed.Seeder.seedModuleFromFile" href="#emse-mms.utils.seed.Seeder.seedModuleFromFile">seedModuleFromFile</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="emse-mms.utils.seed.Skipper" href="#emse-mms.utils.seed.Skipper">Skipper</a></code></h4>
<ul class="two-column">
<li><code><a title="emse-mms.utils.seed.Skipper.all" href="#emse-mms.utils.seed.Skipper.all">all</a></code></li>
<li><code><a title="emse-mms.utils.seed.Skipper.enrollment" href="#emse-mms.utils.seed.Skipper.enrollment">enrollment</a></code></li>
<li><code><a title="emse-mms.utils.seed.Skipper.feedback" href="#emse-mms.utils.seed.Skipper.feedback">feedback</a></code></li>
<li><code><a title="emse-mms.utils.seed.Skipper.module" href="#emse-mms.utils.seed.Skipper.module">module</a></code></li>
<li><code><a title="emse-mms.utils.seed.Skipper.plan" href="#emse-mms.utils.seed.Skipper.plan">plan</a></code></li>
<li><code><a title="emse-mms.utils.seed.Skipper.user" href="#emse-mms.utils.seed.Skipper.user">user</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>